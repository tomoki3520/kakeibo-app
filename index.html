<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>家計簿アプリ</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="manifest" href="/manifest.json">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="家計簿">
  <link rel="apple-touch-icon" href="/icon-192x192.png">

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <link rel="icon" type="image/png" href="/icon-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/icon-512x512.png" sizes="512x512">

  <style>
    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      padding: 1.5em;
      padding-bottom: 60px; /* フッターナビゲーションの高さ分、下部に余白を追加 */
      max-width: 480px;
      margin: auto;
      background: #f0f2f5;
      color: #333;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 1.5em;
      font-size: 2em;
    }

    /* 各セクションの開始位置を示すためにIDにpadding-topとmargin-topを追加 */
    h2 {
      color: #2c3e50;
      margin-top: 2em;
      margin-bottom: 1em;
      padding-top: 60px; /* フッターの高さ分、paddingを追加して要素が隠れないように */
    }
    /* 最初のH2（固定支出の登録）はフォームの後なので、padding-topは不要 */
    h2:first-of-type {
        padding-top: 0;
    }


    form, .fixed-expense-section, .budget-section, .filter-section, .import-section, .recurring-entry-section { /* formに加えて新しいセクションにもスタイル適用 */
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 2em;
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    form label, .fixed-expense-section label, .budget-section label, .filter-section label, .import-section label, .recurring-entry-section label { /* 全てのラベルにスタイル適用 */
      display: block;
      margin-bottom: 0.8em;
      font-weight: bold;
    }

    form label input,
    form label select,
    .fixed-expense-section label input,
    .fixed-expense-section label select,
    .budget-section label input, /* 予算入力フィールド */
    .budget-section label select, /* 予算カテゴリ選択 */
    .filter-section label input, /* 検索入力フィールド */
    .filter-section label select,
    .import-section label input[type="file"], /* CSVインポートファイル入力フィールド */
    .recurring-entry-section label input,
    .recurring-entry-section label select {
      display: block;
      width: calc(100% - 1em);
      padding: 0.7em;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
      box-sizing: border-box;
      margin-top: 0.2em;
    }

    button[type="submit"], .add-fixed-expense-btn, #addMonthlyRecurringEntriesBtn,
    .budget-btn, #searchBtn, #resetFilterBtn, #importCsvBtn, .add-recurring-entry-btn { /* 全てのボタンの共通スタイル */
      background: #28a745;
      color: white;
      border: none;
      padding: 0.8em;
      cursor: pointer;
      margin-top: 0.5em;
      border-radius: 4px;
      transition: background 0.3s ease;
      width: 100%;
    }

    button[type="submit"]:hover, .add-fixed-expense-btn:hover, #addMonthlyRecurringEntriesBtn:hover,
    .budget-btn:hover, #searchBtn:hover, #resetFilterBtn:hover, #importCsvBtn:hover, .add-recurring-entry-btn:hover {
      background: #218838;
    }

    #searchBtn { background: #007bff; }
    #searchBtn:hover { background: #0056b3; }
    #resetFilterBtn { background: #6c757d; }
    #resetFilterBtn:hover { background: #5a6268; }
    #importCsvBtn { background: #007bff; } /* インポートボタンも青 */
    #importCsvBtn:hover { background: #0056b3; }


    ul {
      list-style: none;
      padding: 0;
    }

    /* 日付見出しのスタイル */
    .date-header {
      background-color: #e0e0e0;
      padding: 0.8em 1em;
      margin-top: 1.5em;
      margin-bottom: 0.5em;
      font-weight: bold;
      color: #555;
      border-bottom: 1px solid #ddd;
      border-radius: 4px 4px 0 0;
    }

    /* 各日のリストコンテナ */
    .daily-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* 各履歴アイテムのスタイル */
    .daily-list li {
      background: #ffffff;
      margin: 0.2em 0;
      padding: 0.8em 1em;
      border-left: 5px solid;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.05);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    /* 支出と収入のボーダー色 */
    .expense-item {
      border-color: #dc3545;
    }

    .income-item {
      border-color: #28a745;
    }

    /* 各項目詳細のスタイル */
    .item-details {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3em 0.8em;
      margin-right: 1em;
      align-items: baseline;
    }

    .item-type {
      font-weight: bold;
      color: #333;
      min-width: 45px;
      flex-shrink: 0;
    }
    .item-category {
      color: #333;
      font-weight: 500;
      min-width: 70px;
      flex-shrink: 0;
    }
    .item-amount {
      font-weight: bold;
      color: #000;
      margin-left: auto;
      font-size: 1.1em;
      flex-shrink: 0;
    }
    .item-note {
      font-size: 0.9em;
      color: #666;
      flex-basis: 100%;
      margin-top: 0.3em;
    }
    .item-tags { /* タグの表示スタイル */
      font-size: 0.8em;
      color: #007bff;
      flex-basis: 100%;
      margin-top: 0.3em;
    }

    /* 削除ボタンのスタイル */
    .delete-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 0.4em 0.8em;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      flex-shrink: 0;
      margin-left: 0.5em;
      align-self: center;
      transition: background 0.2s ease;
    }

    .delete-btn:hover {
      background: #c82333;
    }

    /* 月切り替えと分析セクション */
    .month-navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2em;
      margin-bottom: 1.5em;
      background: #ffffff;
      padding: 0.8em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      position: relative; /* monthPickerを絶対配置するため */
    }

    .month-navigation button {
      background: none;
      border: none;
      font-size: 1.5em;
      color: #2c3e50;
      cursor: pointer;
      padding: 0.2em 0.5em;
    }

    .month-display {
      font-size: 1.3em;
      font-weight: bold;
      color: #2c3e50;
      cursor: pointer; /* クリックできることを示す */
      text-decoration: underline; /* クリックできることを示す */
    }

    .summary-section {
      background: #ffffff;
      padding: 1.2em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      margin-bottom: 2em;
      text-align: center;
    }

    .summary-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5em;
      font-size: 1.1em;
    }
    .summary-item span:first-child {
      font-weight: bold;
    }
    .summary-item.income span:last-child { color: #28a745; }
    .summary-item.expense span:last-child { color: #dc3545; }
    .summary-item.total span:last-child { font-weight: bold; color: #2c3e50; }

    /* 予算表示のスタイル */
    .budget-status {
        margin-top: 1.5em;
        padding-top: 1em;
        border-top: 1px solid #eee;
    }
    .budget-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5em;
        font-size: 0.95em;
    }
    .budget-item.warning {
        color: #dc3545; /* 予算オーバー警告色 */
        font-weight: bold;
    }
    .budget-item span:first-child {
        font-weight: bold;
    }


    .chart-tabs {
      display: flex;
      justify-content: space-around;
      margin-bottom: 1.5em;
      background: #ffffff;
      padding: 0.5em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .chart-tabs button {
      flex: 1;
      padding: 0.8em 0.5em;
      border: none;
      background: none;
      font-size: 1em;
      cursor: pointer;
      color: #666;
      border-radius: 6px;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .chart-tabs button.active {
      background: #28a745;
      color: white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .chart-tabs button:hover:not(.active) {
      background: #f0f0f0;
    }

    .chart-container {
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 2em;
    }
    .chart-container canvas {
      max-width: 100%;
      height: auto;
    }

    /* CSVエクスポートボタンのスタイル */
    #exportCsvBtn {
        width: 100%;
        padding: 0.8em;
        background: #007bff; /* 青色 */
        color: white;
        border: none;
        cursor: pointer;
        margin-top: 1em;
        border-radius: 4px;
        transition: background 0.3s ease;
    }
    #exportCsvBtn:hover {
        background: #0056b3; /* ホバーで少し暗く */
    }

    /* 定期支出/収入リストのスタイル */
    #recurringEntryList {
        list-style: none;
        padding: 0;
    }
    #recurringEntryList li {
        background: #f8f8f8;
        padding: 0.8em 1em;
        margin-bottom: 0.5em;
        border-left: 5px solid; /* 種別によって色を変える */
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    #recurringEntryList li.expense-item { border-color: #dc3545; }
    #recurringEntryList li.income-item { border-color: #28a745; }

    #recurringEntryList li .delete-recurring-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 0.3em 0.6em;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7em;
        transition: background 0.2s ease;
    }
    #recurringEntryList li .delete-recurring-btn:hover {
        background: #c82333;
    }

    /* 検索フィルタリングセクション */
    .filter-section .filter-buttons {
        display: flex;
        gap: 0.5em;
    }
    .filter-section .filter-buttons button {
        flex: 1;
    }

    /* 入力候補リスト */
    .autocomplete-list {
        list-style: none;
        padding: 0;
        margin-top: 0.5em;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fff;
        max-height: 150px;
        overflow-y: auto;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        position: absolute; /* 親要素が relative であることを想定 */
        width: calc(100% - 3em); /* body padding 考慮 */
        z-index: 100; /* 他の要素より手前に表示 */
    }
    .autocomplete-list li {
        padding: 0.8em 1em;
        cursor: pointer;
        border-bottom: 1px solid #eee;
    }
    .autocomplete-list li:last-child {
        border-bottom: none;
    }
    .autocomplete-list li:hover {
        background-color: #f0f0f0;
    }

    .form-group-relative {
        position: relative;
    }

    /* --- 新しいCSS: フッターナビゲーション --- */
    .footer-nav {
        position: fixed; /* 画面下部に固定 */
        bottom: 0; /* 下端に配置 */
        left: 0;
        width: 100%;
        max-width: 480px; /* bodyのmax-widthに合わせる */
        left: 50%;
        transform: translateX(-50%); /* 中央揃え */
        background: #343a40; /* ダーク系の背景色 */
        display: flex;
        justify-content: space-around;
        padding: 8px 0;
        box-shadow: 0 -2px 8px rgba(0,0,0,0.2); /* 上部に影 */
        z-index: 1000; /* 他の要素より手前に表示 */
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }

    .footer-nav button {
        background: none;
        border: none;
        color: white;
        font-size: 0.8em;
        padding: 0.5em 0.2em;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        flex: 1; /* 等幅で配置 */
        transition: color 0.2s ease;
    }

    .footer-nav button:hover {
        color: #28a745; /* ホバーでアクセントカラー */
    }

    /* アイコン部分のスタイル (Material Iconsなどを使う場合はフォントサイズで調整) */
    .footer-nav button i {
        font-size: 1.4em; /* アイコンのサイズ */
        margin-bottom: 3px;
    }
  </style>
</head>
<body>
  <h1 id="top">家計簿</h1>
  <form id="expense-form">
    <label>種別：
      <select id="type" required>
        <option value="">選択してください</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>

    <label>日付：
      <input type="date" id="date" required />
    </label>

    <label>カテゴリ：
      <select id="category" required>
        <option value="">まず種別を選んでください</option>
      </select>
    </label>

    <label>金額（円）：
      <input type="number" id="amount" required min="0" />
    </label>

    <label class="form-group-relative">メモ：
      <input type="text" id="note" list="memo-suggestions" />
      <datalist id="memo-suggestions"></datalist>
    </label>

    <label>タグ（カンマ区切り）：
      <input type="text" id="tags" placeholder="例: 食事,外食,ランチ" />
    </label>

    <button type="submit">追加</button>
  </form>

  <h2>CSVデータのインポート</h2>
  <div class="import-section">
    <label for="csvFileInput">
      CSVファイルを選択してインポート:
      <input type="file" id="csvFileInput" accept=".csv"/>
    </label>
    <button type="button" id="importCsvBtn">CSVをインポート</button>
  </div>

  <h2 id="budget-section-h2">予算設定</h2>
  <div class="budget-section">
    <h3>月間予算を設定</h3>
    <label>カテゴリ：
      <select id="budgetCategorySelect" required>
        </select>
    </label>
    <label>予算額（円）：
      <input type="number" id="budgetAmountInput" required min="0" />
    </label>
    <button type="button" id="setBudgetBtn" class="budget-btn">予算を設定</button>

    <h3>現在の予算設定</h3>
    <ul id="budgetList">
      </ul>
  </div>

  <h2 id="recurring-entry-section-h2">定期的な記録の登録</h2>
  <div class="recurring-entry-section">
    <label>種別：
      <select id="recurringType" required>
        <option value="">選択してください</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>
    <label>カテゴリ：
      <select id="recurringCategory" required>
        </select>
    </label>
    <label>金額（円）：
      <input type="number" id="recurringAmount" required min="0" />
    </label>
    <label>メモ：
      <input type="text" id="recurringNote" />
    </label>
    <label>追加日（毎月）：
      <input type="number" id="recurringDay" required min="1" max="31" placeholder="例: 25 (毎月25日)" />
    </label>
    <button type="button" id="addRecurringEntryBtn" class="add-recurring-entry-btn">定期的な記録を登録</button>

    <h3>登録済みの定期的な記録</h3>
    <ul id="recurringEntryList">
      </ul>
    <button type="button" id="addMonthlyRecurringEntriesBtn">今月に定期的な記録を一括追加</button>
  </div>


  <h2 id="history-section-h2">履歴</h2>
  <div class="month-navigation">
    <button id="prevMonth">&lt;</button>
    <span id="currentMonthDisplay" class="month-display"></span>
    <input type="month" id="monthPicker" style="opacity: 0; pointer-events: none; position: absolute; width: 1px; height: 1px;">
    <button id="nextMonth">&gt;</button>
  </div>

  <div class="filter-section">
    <h3>履歴の検索・絞り込み</h3>
    <label>キーワード（メモ・タグ）：
      <input type="search" id="filterKeyword" placeholder="例: ランチ, #旅行" />
    </label>
    <label>種別：
      <select id="filterType">
        <option value="">すべて</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>
    <label>カテゴリ：
      <select id="filterCategory">
        <option value="">すべて</option>
        </select>
    </label>
    <label>金額（下限）：
      <input type="number" id="filterAmountMin" min="0" />
    </label>
    <label>金額（上限）：
      <input type="number" id="filterAmountMax" min="0" />
    </label>
    <div class="filter-buttons">
        <button type="button" id="searchBtn">検索</button>
        <button type="button" id="resetFilterBtn">リセット</button>
    </div>
  </div>

  <ul id="history"></ul>

  <button id="exportCsvBtn">CSVでエクスポート</button>

  <h2 id="analysis-section-h2">分析</h2>
  <div class="summary-section">
    <div class="summary-item income">
      <span>収入</span><span id="totalIncome">¥0</span>
    </div>
    <div class="summary-item expense">
      <span>支出</span><span id="totalExpense">¥0</span>
    </div>
    <hr style="margin: 1em 0; border: none; border-top: 1px solid #eee;">
    <div class="summary-item total">
      <span>合計</span><span id="balance">¥0</span>
    </div>
    <div class="budget-status" id="budgetStatus">
        <h3>今月の予算実績</h3>
        <p style="text-align: center; color: #777; font-size: 0.9em;" id="noBudgetSetMessage">予算が設定されていません。</p>
        </div>
  </div>

  <div class="chart-tabs">
    <button id="pieChartTab" class="active">カテゴリ別（円グラフ）</button>
    <button id="monthlyBarChartTab">月別推移（棒グラフ）</button>
    <button id="yearlyBarChartTab">年別推移（棒グラフ）</button>
  </div>

  <div class="chart-container">
    <canvas id="myChart"></canvas>
  </div>

  <div class="footer-nav">
    <button class="nav-button" data-target="top">
        <i class="material-icons">add_circle_outline</i>
        <span>入力</span>
    </button>
    <button class="nav-button" data-target="budget-section-h2">
        <i class="material-icons">account_balance_wallet</i>
        <span>予算</span>
    </button>
    <button class="nav-button" data-target="recurring-entry-section-h2">
        <i class="material-icons">event_note</i>
        <span>定期</span>
    </button>
    <button class="nav-button" data-target="history-section-h2">
        <i class="material-icons">history</i>
        <span>履歴</span>
    </button>
    <button class="nav-button" data-target="analysis-section-h2">
        <i class="material-icons">bar_chart</i>
        <span>分析</span>
    </button>
  </div>

  <script>
    // 定数定義
    const CACHE_NAME = 'kakeibo-app-cache-v2'; // キャッシュバージョンを更新
    const DB_NAME = 'kakeiboDB';
    const DB_VERSION = 1;
    const STORE_NAMES = {
        ENTRIES: 'entries',
        RECURRING_ENTRIES: 'recurringEntries', // fixedExpenses から recurringEntries に変更
        BUDGETS: 'budgets'
    };
    const CATEGORY_OPTIONS = {
      "支出": [
        "食費", "日用品", "住居", "光熱費", "通信費", "保険", "医療費",
        "被服・美容", "交通", "教育・書籍", "娯楽・交際", "サブスク",
        "税金・年金", "その他"
      ],
      "収入": [
        "給与", "副業", "お小遣い", "配当・投資", "賞与", "その他"
      ]
    };
    const NOTIFICATION_CHANNEL_ID = 'kakeibo-notifications';

    // DOM要素の取得
    const form = document.getElementById("expense-form");
    const historyList = document.getElementById("history");
    const typeSelect = document.getElementById("type");
    const categorySelect = document.getElementById("category");
    const amountInput = document.getElementById("amount");
    const noteInput = document.getElementById("note");
    const tagsInput = document.getElementById("tags");
    const currentMonthDisplay = document.getElementById("currentMonthDisplay");
    const prevMonthBtn = document.getElementById("prevMonth");
    const nextMonthBtn = document.getElementById("nextMonth");
    const totalIncomeSpan = document.getElementById("totalIncome");
    const totalExpenseSpan = document.getElementById("totalExpense");
    const balanceSpan = document.getElementById("balance");
    const pieChartTab = document.getElementById("pieChartTab");
    const monthlyBarChartTab = document.getElementById("monthlyBarChartTab"); // 新しいタブ
    const yearlyBarChartTab = document.getElementById("yearlyBarChartTab");   // 新しいタブ
    const myChartCanvas = document.getElementById("myChart");
    const exportCsvBtn = document.getElementById("exportCsvBtn");
    const csvFileInput = document.getElementById("csvFileInput");
    const importCsvBtn = document.getElementById("importCsvBtn");
    const monthPicker = document.getElementById("monthPicker");

    // 定期的な記録関連のDOM要素 (旧fixed-expense)
    const recurringTypeSelect = document.getElementById("recurringType");
    const recurringCategorySelect = document.getElementById("recurringCategory");
    const recurringAmountInput = document.getElementById("recurringAmount");
    const recurringNoteInput = document.getElementById("recurringNote");
    const recurringDayInput = document.getElementById("recurringDay");
    const addRecurringEntryBtn = document.getElementById("addRecurringEntryBtn");
    const recurringEntryList = document.getElementById("recurringEntryList");
    const addMonthlyRecurringEntriesBtn = document.getElementById("addMonthlyRecurringEntriesBtn");

    // 予算設定関連のDOM要素
    const budgetCategorySelect = document.getElementById("budgetCategorySelect");
    const budgetAmountInput = document.getElementById("budgetAmountInput");
    const setBudgetBtn = document.getElementById("setBudgetBtn");
    const budgetList = document.getElementById("budgetList");
    const budgetStatusDiv = document.getElementById("budgetStatus");
    const noBudgetSetMessage = document.getElementById("noBudgetSetMessage");

    // フィルタリング・検索関連のDOM要素
    const filterKeywordInput = document.getElementById("filterKeyword");
    const filterTypeSelect = document.getElementById("filterType");
    const filterCategorySelect = document.getElementById("filterCategory");
    const filterAmountMinInput = document.getElementById("filterAmountMin");
    const filterAmountMaxInput = document.getElementById("filterAmountMax");
    const searchBtn = document.getElementById("searchBtn");
    const resetFilterBtn = document.getElementById("resetFilterBtn");
    const memoSuggestionsDatalist = document.getElementById("memo-suggestions");


    // グローバル変数
    let customCategories = new Set();
    let pastNotes = new Set();
    let currentMonth = new Date();
    let myChartInstance;
    let db; // IndexedDBインスタンス

    // --- IndexedDB関連関数 ---
    async function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAMES.ENTRIES)) {
                    const entriesStore = db.createObjectStore(STORE_NAMES.ENTRIES, { keyPath: 'id', autoIncrement: true });
                    entriesStore.createIndex('date', 'date', { unique: false });
                    entriesStore.createIndex('type', 'type', { unique: false });
                    entriesStore.createIndex('category', 'category', { unique: false });
                    entriesStore.createIndex('note', 'note', { unique: false });
                    entriesStore.createIndex('tags', 'tags', { unique: false });
                }
                // 固定支出ストアの名前を recurringEntries に変更、dayIndex を追加
                if (!db.objectStoreNames.contains(STORE_NAMES.RECURRING_ENTRIES)) {
                    const recurringStore = db.createObjectStore(STORE_NAMES.RECURRING_ENTRIES, { keyPath: 'id', autoIncrement: true });
                    recurringStore.createIndex('type', 'type', { unique: false });
                    recurringStore.createIndex('category', 'category', { unique: false });
                    recurringStore.createIndex('day', 'day', { unique: false }); // 追加日用インデックス
                }
                if (!db.objectStoreNames.contains(STORE_NAMES.BUDGETS)) {
                    db.createObjectStore(STORE_NAMES.BUDGETS, { keyPath: 'category' });
                }
                console.log('IndexedDB upgraded or created successfully.');
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('IndexedDB opened successfully.');
                resolve(db);
            };

            request.onerror = (event) => {
                console.error('IndexedDB error:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function saveData(storeName, data) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);

            const request = store.put(data);

            request.onsuccess = () => {
                // console.log(`Data saved to IndexedDB (${storeName}):`, data);
                resolve();
            };

            request.onerror = (event) => {
                console.error(`Error saving data to IndexedDB (${storeName}):`, event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function loadAllDataFromStore(storeName) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = (event) => {
                resolve(event.target.result);
            };

            request.onerror = (event) => {
                console.error(`Error loading data from IndexedDB (${storeName}):`, event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function deleteDataFromStore(storeName, id) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);

            request.onsuccess = () => {
                console.log(`Data deleted from IndexedDB (${storeName}):`, id);
                resolve();
            };

            request.onerror = (event) => {
                console.error(`Error deleting data from IndexedDB (${storeName}):`, event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    // --- メインアプリロジック ---
    document.getElementById("date").valueAsDate = new Date();
    typeSelect.addEventListener("change", updateCategoryOptions);
    recurringTypeSelect.addEventListener("change", updateRecurringCategoryOptions);


    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const data = {
        type: typeSelect.value,
        date: document.getElementById("date").value,
        category: categorySelect.value,
        amount: parseInt(amountInput.value, 10),
        note: noteInput.value,
        tags: tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '')
      };

      if (!data.type || !data.date || !data.category || isNaN(data.amount) || data.amount <= 0) {
        alert("種別、日付、カテゴリ、金額は必須入力です。金額は正の数値を入力してください。");
        return;
      }

      if (data.category === "その他" && data.note) {
          customCategories.add(data.note);
      }
      if (data.note) {
          pastNotes.add(data.note);
      }

      await saveData(STORE_NAMES.ENTRIES, data);
      await loadAndDisplayData();
      form.reset();
      updateCategoryOptions();
      updateMemoSuggestions();
    });

    function updateCategoryOptions() {
      const type = typeSelect.value;
      categorySelect.innerHTML = '<option value="">選択してください</option>';

      if (CATEGORY_OPTIONS[type]) {
        CATEGORY_OPTIONS[type].forEach(cat => {
          const opt = document.createElement("option");
          opt.value = cat;
          opt.textContent = cat;
          categorySelect.appendChild(opt);
        });
      } else {
        categorySelect.innerHTML = '<option value="">まず種別を選んでください</option>';
      }

      // カスタムカテゴリを追加
      Array.from(customCategories).sort().forEach(cat => {
          if (!CATEGORY_OPTIONS["支出"].includes(cat) && !CATEGORY_OPTIONS["収入"].includes(cat)) {
              const opt = document.createElement("option");
              opt.value = cat;
              opt.textContent = `${cat} (その他)`;
              categorySelect.appendChild(opt);
          }
      });
    }

    function updateRecurringCategoryOptions() {
        const type = recurringTypeSelect.value;
        recurringCategorySelect.innerHTML = '<option value="">選択してください</option>';

        if (CATEGORY_OPTIONS[type]) {
            CATEGORY_OPTIONS[type].forEach(cat => {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = cat;
                recurringCategorySelect.appendChild(opt);
            });
        }
        // カスタムカテゴリも追加
        Array.from(customCategories).sort().forEach(cat => {
            if (type === '支出' && !CATEGORY_OPTIONS["支出"].includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `${cat} (その他)`;
                recurringCategorySelect.appendChild(opt);
            } else if (type === '収入' && !CATEGORY_OPTIONS["収入"].includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `${cat} (その他)`;
                recurringCategorySelect.appendChild(opt);
            }
        });
    }

    function updateMemoSuggestions() {
        memoSuggestionsDatalist.innerHTML = '';
        pastNotes.forEach(note => {
            const option = document.createElement('option');
            option.value = note;
            memoSuggestionsDatalist.appendChild(option);
        });
    }

    async function loadAllDataForSuggestions() {
        const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        customCategories.clear();
        pastNotes.clear();

        allEntries.forEach(item => {
            // "その他"カテゴリでメモが使われていたらカスタムカテゴリとして記憶
            if (item.category === "その他" && item.note) {
                customCategories.add(item.note);
            } else if (!CATEGORY_OPTIONS["支出"].includes(item.category) && !CATEGORY_OPTIONS["収入"].includes(item.category)) {
                // 定義済みカテゴリになく、メモがある場合もカスタムカテゴリとして記憶
                customCategories.add(item.category);
            }
            if (item.note) {
                pastNotes.add(item.note);
            }
        });
        updateCategoryOptions();
        updateRecurringCategoryOptions(); // 定期的な記録のカテゴリも更新
        updateMemoSuggestions();
    }

    async function loadAndDisplayData() {
        let allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        historyList.innerHTML = "";

        const filterKeyword = filterKeywordInput.value.toLowerCase();
        const filterType = filterTypeSelect.value;
        const filterCategory = filterCategorySelect.value;
        const filterAmountMin = parseInt(filterAmountMinInput.value, 10);
        const filterAmountMax = parseInt(filterAmountMaxInput.value, 10);

        const filteredData = allEntries.filter(item => {
            const keywordMatch = !filterKeyword ||
                                  (item.note && item.note.toLowerCase().includes(filterKeyword)) ||
                                  (item.tags && item.tags.some(tag => tag.toLowerCase().includes(filterKeyword)));

            const typeMatch = !filterType || item.type === filterType;
            const categoryMatch = !filterCategory || item.category === filterCategory;
            const amountMatch = (isNaN(filterAmountMin) || item.amount >= filterAmountMin) &&
                                 (isNaN(filterAmountMax) || item.amount <= filterAmountMax);

            return keywordMatch && typeMatch && categoryMatch && amountMatch;
        });

        const currentMonthYear = currentMonth.getFullYear();
        const currentMonthMonth = currentMonth.getMonth();

        const monthlyData = filteredData.filter(item => {
            const itemDate = new Date(item.date);
            // Dateオブジェクトのパースは 'YYYY-MM-DD' 形式を推奨
            const [year, month, day] = item.date.split('-').map(Number);
            const itemParsedDate = new Date(year, month - 1, day); // 月は0始まり

            return itemParsedDate.getFullYear() === currentMonthYear && itemParsedDate.getMonth() === currentMonthMonth;
        });

        monthlyData.sort((a, b) => {
            const dateA = new Date(a.date);
            const dateB = new Date(b.date);
            if (dateA.getTime() === dateB.getTime()) {
                // 日付が同じ場合はタイプ（支出優先）と金額でソート
                if (a.type === "支出" && b.type === "収入") return -1;
                if (a.type === "収入" && b.type === "支出") return 1;
                return b.amount - a.amount; // 金額降順
            }
            return dateB - dateA; // 日付降順
        });


        const groupedData = {};
        monthlyData.forEach(item => {
            if (!groupedData[item.date]) {
                groupedData[item.date] = [];
            }
            groupedData[item.date].push(item);
        });

        if (Object.keys(groupedData).length === 0) {
            historyList.innerHTML = '<p style="text-align: center; color: #777; margin-top: 2em;">この月には履歴がありません。</p>';
            if (filterKeyword || filterType || filterCategory || !isNaN(filterAmountMin) || !isNaN(filterAmountMax)) {
                historyList.innerHTML += '<p style="text-align: center; color: #777; font-size: 0.9em;">（検索条件に合う項目が見つかりませんでした）</p>';
            }
        } else {
            for (const date in groupedData) {
                if (groupedData.hasOwnProperty(date)) {
                    const dailyItems = groupedData[date];

                    const dateHeader = document.createElement("div");
                    dateHeader.className = "date-header";
                    const [year, month, day] = date.split('-');
                    const dayOfWeek = new Date(year, month - 1, day).toLocaleDateString('ja-JP', { weekday: 'short' });
                    const formattedDate = `${year}年${parseInt(month)}月${parseInt(day)}日 (${dayOfWeek})`;

                    dateHeader.textContent = formattedDate;
                    historyList.appendChild(dateHeader);

                    const ul = document.createElement("ul");
                    ul.className = "daily-list";

                    dailyItems.forEach((item) => {
                        const li = document.createElement("li");
                        li.className = item.type === "支出" ? "expense-item" : "income-item";
                        li.innerHTML = `
                            <span class="item-details">
                              <span class="item-type">${item.type}</span>
                              <span class="item-category">${item.category}</span>
                              <span class="item-amount">¥${item.amount.toLocaleString()}</span>
                              ${item.note ? `<span class="item-note">${item.note}</span>` : ''}
                              ${item.tags && item.tags.length > 0 ? `<span class="item-tags">${item.tags.map(tag => `#${tag}`).join(' ')}</span>` : ''}
                            </span>
                            <button class="delete-btn" data-id="${item.id}" data-store="${STORE_NAMES.ENTRIES}">削除</button>
                        `;
                        ul.appendChild(li);
                    });
                    historyList.appendChild(ul);
                }
            }
        }

        document.querySelectorAll('.delete-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const idToDelete = parseInt(e.target.dataset.id, 10);
                const storeName = e.target.dataset.store;
                if (confirm("この項目を削除してもよろしいですか？")) {
                    await deleteDataFromStore(storeName, idToDelete);
                    await loadAndDisplayData();
                    await loadAllDataForSuggestions();
                }
            });
        });

        updateMonthDisplay();
        updateSummary(monthlyData);
        await updateCharts(); // await を追加
        updateBudgetStatus(monthlyData);
    }


    function updateMonthDisplay() {
      const year = currentMonth.getFullYear();
      const month = currentMonth.getMonth() + 1;
      currentMonthDisplay.textContent = `${year}年${month}月`;
      monthPicker.value = `${year}-${month.toString().padStart(2, '0')}`;
    }

    currentMonthDisplay.addEventListener('click', () => {
        monthPicker.click();
    });

    monthPicker.addEventListener('change', async () => {
        const [year, month] = monthPicker.value.split('-').map(Number);
        currentMonth.setFullYear(year, month - 1, 1);
        await loadAndDisplayData();
    });

    prevMonthBtn.addEventListener("click", async () => {
      currentMonth.setMonth(currentMonth.getMonth() - 1);
      await loadAndDisplayData();
    });

    nextMonthBtn.addEventListener("click", async () => {
      currentMonth.setMonth(currentMonth.getMonth() + 1);
      await loadAndDisplayData();
    });


    function updateSummary(data) {
      let totalIncome = 0;
      let totalExpense = 0;

      data.forEach(item => {
        if (item.type === "収入") {
          totalIncome += item.amount;
        } else if (item.type === "支出") {
          totalExpense += item.amount;
        }
      });

      totalIncomeSpan.textContent = `¥${totalIncome.toLocaleString()}`;
      totalExpenseSpan.textContent = `¥${totalExpense.toLocaleString()}`;
      balanceSpan.textContent = `¥${(totalIncome - totalExpense).toLocaleString()}`;
    }

    // --- グラフ関連 ---
    async function updateCharts() {
      if (myChartInstance) {
        myChartInstance.destroy();
      }

      const activeTab = document.querySelector('.chart-tabs button.active').id;
      const monthlyData = await filterAndSortMonthlyData(); // 月別データ取得
      const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || []; // 全データ取得

      if (activeTab === 'pieChartTab') {
        renderPieChart(monthlyData);
      } else if (activeTab === 'monthlyBarChartTab') {
        renderMonthlyBarChart(allEntries);
      } else if (activeTab === 'yearlyBarChartTab') {
        renderYearlyBarChart(allEntries); // 新しいグラフの描画
      }
    }

    function renderPieChart(monthlyData) {
      const expenseByCategory = {};
      monthlyData.filter(item => item.type === "支出").forEach(item => {
        // カスタムカテゴリを考慮
        const actualCategory = (item.category === "その他" && item.note && customCategories.has(item.note)) ? item.note : item.category;
        expenseByCategory[actualCategory] = (expenseByCategory[actualCategory] || 0) + item.amount;
      });

      const labels = Object.keys(expenseByCategory);
      const dataValues = Object.values(expenseByCategory);
      const backgroundColors = generateColors(labels.length);

      myChartInstance = new Chart(myChartCanvas, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: dataValues,
            backgroundColor: backgroundColors,
            hoverOffset: 4
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            },
            title: {
              display: true,
              text: '月間支出カテゴリ別内訳'
            }
          }
        }
      });
    }

    function renderMonthlyBarChart(allData) {
        const monthlySummary = {};

        allData.forEach(item => {
            const [year, month] = item.date.split('-').map(Number);
            const yearMonth = `${year}-${month.toString().padStart(2, '0')}`;

            if (!monthlySummary[yearMonth]) {
                monthlySummary[yearMonth] = { income: 0, expense: 0 };
            }

            if (item.type === "収入") {
                monthlySummary[yearMonth].income += item.amount;
            } else if (item.type === "支出") {
                monthlySummary[yearMonth].expense += item.amount;
            }
        });

        const sortedMonths = Object.keys(monthlySummary).sort();

        const incomes = sortedMonths.map(month => monthlySummary[month].income);
        const expenses = sortedMonths.map(month => monthlySummary[month].expense);

        myChartInstance = new Chart(myChartCanvas, {
            type: 'bar',
            data: {
                labels: sortedMonths,
                datasets: [
                    {
                        label: '収入',
                        data: incomes,
                        backgroundColor: 'rgba(40, 167, 69, 0.7)',
                        borderColor: 'rgba(40, 167, 69, 1)',
                        borderWidth: 1
                    },
                    {
                        label: '支出',
                        data: expenses,
                        backgroundColor: 'rgba(220, 53, 69, 0.7)',
                        borderColor: 'rgba(220, 53, 69, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: '月別収支推移'
                    }
                },
                scales: {
                    x: {
                        stacked: false
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false
                    }
                }
            }
        });
    }

    // 新しいグラフ: 年別収支推移の棒グラフ
    function renderYearlyBarChart(allData) {
        const yearlySummary = {};

        allData.forEach(item => {
            const [year] = item.date.split('-').map(Number);
            const yearString = String(year);

            if (!yearlySummary[yearString]) {
                yearlySummary[yearString] = { income: 0, expense: 0 };
            }

            if (item.type === "収入") {
                yearlySummary[yearString].income += item.amount;
            } else if (item.type === "支出") {
                yearlySummary[yearString].expense += item.amount;
            }
        });

        const sortedYears = Object.keys(yearlySummary).sort();

        const incomes = sortedYears.map(year => yearlySummary[year].income);
        const expenses = sortedYears.map(year => yearlySummary[year].expense);

        myChartInstance = new Chart(myChartCanvas, {
            type: 'bar',
            data: {
                labels: sortedYears,
                datasets: [
                    {
                        label: '収入',
                        data: incomes,
                        backgroundColor: 'rgba(40, 167, 69, 0.7)',
                        borderColor: 'rgba(40, 167, 69, 1)',
                        borderWidth: 1
                    },
                    {
                        label: '支出',
                        data: expenses,
                        backgroundColor: 'rgba(220, 53, 69, 0.7)',
                        borderColor: 'rgba(220, 53, 69, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: '年別収支推移'
                    }
                },
                scales: {
                    x: {
                        stacked: false
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false
                    }
                }
            }
        });
    }


    function generateColors(numColors) {
      const colors = [];
      const hueStep = 360 / numColors;
      for (let i = 0; i < numColors; i++) {
        const hue = i * hueStep;
        colors.push(`hsl(${hue}, 70%, 60%)`);
      }
      return colors;
    }

    pieChartTab.addEventListener('click', async () => {
      document.querySelectorAll('.chart-tabs button').forEach(btn => btn.classList.remove('active'));
      pieChartTab.classList.add('active');
      await updateCharts();
    });

    monthlyBarChartTab.addEventListener('click', async () => {
      document.querySelectorAll('.chart-tabs button').forEach(btn => btn.classList.remove('active'));
      monthlyBarChartTab.classList.add('active');
      await updateCharts();
    });

    yearlyBarChartTab.addEventListener('click', async () => {
      document.querySelectorAll('.chart-tabs button').forEach(btn => btn.classList.remove('active'));
      yearlyBarChartTab.classList.add('active');
      await updateCharts();
    });


    async function filterAndSortMonthlyData() {
        const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        const currentMonthYear = currentMonth.getFullYear();
        const currentMonthMonth = currentMonth.getMonth();

        return allEntries.filter(item => {
            const [year, month, day] = item.date.split('-').map(Number);
            const itemDate = new Date(year, month - 1, day);
            return itemDate.getFullYear() === currentMonthYear && itemDate.getMonth() === currentMonthMonth;
        });
    }


    exportCsvBtn.addEventListener('click', async () => {
        const allData = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        if (allData.length === 0) {
            alert("エクスポートするデータがありません。");
            return;
        }

        const headers = ["日付", "種別", "カテゴリ", "金額", "メモ", "タグ"];
        const csvRows = allData.map(item => {
            const escapeCsv = (value) => {
                if (value === null || value === undefined) return '';
                let stringValue = String(value);
                if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                    return `"${stringValue.replace(/"/g, '""')}"`;
                }
                return stringValue;
            };

            const tagsString = item.tags ? item.tags.join(',') : '';
            return [
                escapeCsv(item.date),
                escapeCsv(item.type),
                escapeCsv(item.category),
                escapeCsv(item.amount),
                escapeCsv(item.note),
                escapeCsv(tagsString)
            ].join(',');
        });

        const csvContent = [headers.join(','), ...csvRows].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

        const link = document.createElement('a');
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', '家計簿データ.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("お使いのブラウザはCSVエクスポートに対応していません。");
        }
    });

    importCsvBtn.addEventListener('click', () => {
        const file = csvFileInput.files[0];
        if (!file) {
            alert("CSVファイルを選択してください。");
            return;
        }

        if (!confirm("CSVファイルをインポートしますか？既存のデータに**追加**されます。（同じ内容が重複する可能性があります）")) {
            return;
        }

        const reader = new FileReader();

        reader.onload = async (e) => {
            const csvText = e.target.result;
            try {
                await parseAndImportCsv(csvText);
                alert("CSVデータのインポートが完了しました！");
                csvFileInput.value = '';
                await loadAndDisplayData();
                await loadAllDataForSuggestions();
            } catch (error) {
                console.error("CSVインポートエラー:", error);
                alert("CSVファイルの読み込み中にエラーが発生しました。ファイル形式を確認してください。\n" + error.message);
            }
        };

        reader.onerror = (e) => {
            console.error("ファイル読み込みエラー:", e);
            alert("ファイルの読み込み中にエラーが発生しました。");
        };

        reader.readAsText(file, 'UTF-8');
    });

    async function parseAndImportCsv(csvText) {
        const lines = csvText.trim().split('\n').slice(1);

        if (lines.length === 0) {
            console.warn("CSVファイルにデータ行がありません。");
            return;
        }

        for (const line of lines) {
            const values = line.match(/(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|([^,]*))(?:,|$)/g)
                               .map(match => {
                                   let val = match.endsWith(',') ? match.slice(0, -1) : match;
                                   if (val.startsWith('"') && val.endsWith('"')) {
                                       val = val.slice(1, -1).replace(/\"\"/g, '\"');
                                   }
                                   return val;
                               }).filter(val => val !== "");

            if (values.length >= 4) {
                const type = values[1];
                const date = values[0];
                const category = values[2];
                const amount = parseInt(values[3], 10);
                const note = values[4] || '';
                const tagsString = values[5] || '';
                const tags = tagsString ? tagsString.split(',').map(tag => tag.trim()).filter(t => t !== '') : [];

                if (!type || !date || !category || isNaN(amount) || amount < 0) { // 金額は0以上を許容
                    console.warn("不正なデータ形式の行をスキップしました:", line);
                    continue;
                }

                // 日付の形式チェック (YYYY-MM-DD)
                if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                    console.warn("不正な日付形式の行をスキップしました:", line);
                    continue;
                }
                const parsedDate = new Date(date);
                if (isNaN(parsedDate.getTime())) {
                    console.warn("無効な日付の行をスキップしました:", line);
                    continue;
                }

                const data = { type, date, category, amount, note, tags };
                await saveData(STORE_NAMES.ENTRIES, data);
            } else {
                console.warn("列数が足りない行をスキップしました:", line);
            }
        }
    }

    // --- 定期的な記録機能 (旧 固定支出) ---
    async function renderRecurringEntryList() {
        const recurringEntries = await loadAllDataFromStore(STORE_NAMES.RECURRING_ENTRIES);
        recurringEntryList.innerHTML = '';
        if (recurringEntries.length === 0) {
            recurringEntryList.innerHTML = '<p style="text-align: center; color: #777; font-size: 0.9em;">登録済みの定期的な記録はありません。</p>';
            return;
        }
        recurringEntries.forEach((item) => {
            const li = document.createElement('li');
            li.className = item.type === "支出" ? "expense-item" : "income-item";
            li.innerHTML = `
                <span>${item.type}・${item.category}: ¥${item.amount.toLocaleString()} (毎月 ${item.day}日) ${item.note ? `(${item.note})` : ''}</span>
                <button class="delete-recurring-btn" data-id="${item.id}" data-store="${STORE_NAMES.RECURRING_ENTRIES}">削除</button>
            `;
            recurringEntryList.appendChild(li);
        });

        document.querySelectorAll('.delete-recurring-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const idToDelete = parseInt(e.target.dataset.id, 10);
                const storeName = e.target.dataset.store;
                if (confirm("この定期的な記録を削除してもよろしいですか？")) {
                    await deleteDataFromStore(storeName, idToDelete);
                    renderRecurringEntryList();
                }
            });
        });
    }

    addRecurringEntryBtn.addEventListener('click', async () => {
        const type = recurringTypeSelect.value;
        const category = recurringCategorySelect.value;
        const amount = parseInt(recurringAmountInput.value, 10);
        const note = recurringNoteInput.value;
        const day = parseInt(recurringDayInput.value, 10);

        if (!type || !category || isNaN(amount) || amount <= 0 || isNaN(day) || day < 1 || day > 31) {
            alert("種別、カテゴリ、金額、追加日（1-31）は必須入力です。金額は正の数値を入力してください。");
            return;
        }

        const data = { type, category, amount, note, day };
        await saveData(STORE_NAMES.RECURRING_ENTRIES, data);
        renderRecurringEntryList();
        recurringAmountInput.value = '';
        recurringNoteInput.value = '';
        recurringTypeSelect.value = '';
        recurringCategorySelect.value = '';
        recurringDayInput.value = '';
        updateRecurringCategoryOptions(); // カテゴリ選択をリセット
    });

    addMonthlyRecurringEntriesBtn.addEventListener('click', async () => {
        const recurringEntries = await loadAllDataFromStore(STORE_NAMES.RECURRING_ENTRIES);
        if (recurringEntries.length === 0) {
            alert("登録済みの定期的な記録がありません。");
            return;
        }

        if (!confirm("今月に登録済みの定期的な記録をすべて追加しますか？（重複登録にご注意ください）")) {
            return;
        }

        const today = new Date();
        const year = today.getFullYear();
        const month = (today.getMonth() + 1).toString().padStart(2, '0');

        let addedCount = 0;
        for (const recurringItem of recurringEntries) {
            const day = recurringItem.day.toString().padStart(2, '0');
            const dateString = `${year}-${month}-${day}`;

            // 月末の日付を超える場合は月末に調整
            const checkDate = new Date(dateString);
            if (checkDate.getMonth() !== today.getMonth()) { // 例えば2/30のような日付の場合
                const lastDayOfMonth = new Date(year, today.getMonth() + 1, 0).getDate();
                recurringItem.day = lastDayOfMonth; // 実際のデータは変更せず、記録する日付を調整
                const adjustedDateString = `${year}-${month}-${lastDayOfMonth.toString().padStart(2, '0')}`;
                console.log(`日付を調整: ${dateString} -> ${adjustedDateString}`);
            }

            const data = {
                type: recurringItem.type,
                date: dateString,
                category: recurringItem.category,
                amount: recurringItem.amount,
                note: `[定期] ${recurringItem.note || recurringItem.category}`,
                tags: ['定期費'] // tags は任意で追加
            };

            // 既にその月に同じ日付、種別、カテゴリ、金額の記録があるかチェック（簡易的な重複防止）
            const existingEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES);
            const isDuplicate = existingEntries.some(entry =>
                entry.date === data.date &&
                entry.type === data.type &&
                entry.category === data.category &&
                entry.amount === data.amount
            );

            if (!isDuplicate) {
                await saveData(STORE_NAMES.ENTRIES, data);
                addedCount++;
            } else {
                console.log(`重複のためスキップ: ${data.category} (${data.date})`);
            }
        }
        alert(`${addedCount}件の定期的な記録を今月に追加しました。`);
        await loadAndDisplayData();
    });


    // --- 予算設定の機能 ---
    async function saveBudgets(budgets) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readwrite');
            const store = transaction.objectStore(STORE_NAMES.BUDGETS);

            const clearRequest = store.clear(); // 全削除してから保存
            clearRequest.onsuccess = () => {
                const budgetCategories = Object.keys(budgets);
                let addCount = 0;
                if (budgetCategories.length === 0) {
                    resolve(); // 予算がない場合も成功とみなす
                    return;
                }

                budgetCategories.forEach(category => {
                    const budgetItem = { category: category, amount: budgets[category] };
                    const addRequest = store.put(budgetItem);
                    addRequest.onsuccess = () => {
                        addCount++;
                        if (addCount === budgetCategories.length) {
                            console.log('Budgets saved to IndexedDB.');
                            resolve();
                        }
                    };
                    addRequest.onerror = (event) => console.error('Error adding budget:', event.target.errorCode);
                });
            };
            clearRequest.onerror = (event) => {
                console.error('Error clearing budgets store:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function loadBudgets() {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readonly');
            const store = transaction.objectStore(STORE_NAMES.BUDGETS);
            const request = store.getAll();

            request.onsuccess = (event) => {
                const result = event.target.result;
                const budgets = {};
                result.forEach(item => {
                    budgets[item.category] = item.amount;
                });
                resolve(budgets);
            };
            request.onerror = (event) => {
                console.error('Error loading budgets from IndexedDB:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function renderBudgetList() {
        const budgets = await loadBudgets();
        budgetList.innerHTML = '';
        const budgetCategories = Object.keys(budgets);

        if (budgetCategories.length === 0) {
            budgetList.innerHTML = '<p style="text-align: center; color: #777; font-size: 0.9em;">予算が設定されていません。</p>';
            return;
        }

        budgetCategories.forEach(category => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${category}: ¥${budgets[category].toLocaleString()}</span>
                <button class="delete-budget-btn" data-category="${category}">削除</button>
            `;
            budgetList.appendChild(li);
        });

        document.querySelectorAll('.delete-budget-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const categoryToDelete = e.target.dataset.category;
                await deleteBudget(categoryToDelete);
            });
        });
    }

    async function deleteBudget(category) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            if (confirm(`${category}の予算を削除してもよろしいですか？`)) {
                const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readwrite');
                const store = db.objectStore(STORE_NAMES.BUDGETS);
                const request = store.delete(category);

                request.onsuccess = () => {
                    console.log('Budget deleted from IndexedDB:', category);
                    renderBudgetList();
                    updateBudgetStatus(filterAndSortMonthlyData());
                    resolve();
                };
                request.onerror = (event) => {
                    console.error('Error deleting budget from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            } else {
                resolve();
            }
        });
    }

    setBudgetBtn.addEventListener('click', async () => {
        const category = budgetCategorySelect.value;
        const amount = parseInt(budgetAmountInput.value, 10);

        if (!category || isNaN(amount) || amount < 0) {
            alert("カテゴリと予算額は必須入力です。予算額は数値で入力してください。");
            return;
        }

        let budgets = await loadBudgets();
        budgets[category] = amount;
        await saveBudgets(budgets);
        renderBudgetList();
        budgetAmountInput.value = '';
        budgetCategorySelect.value = '';
        updateBudgetStatus(await filterAndSortMonthlyData());
    });

    function initBudgetCategorySelect() {
        const expenseCategories = CATEGORY_OPTIONS["支出"];
        budgetCategorySelect.innerHTML = '<option value="">選択してください</option>';
        expenseCategories.forEach(cat => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.textContent = cat;
            budgetCategorySelect.appendChild(opt);
        });
        // カスタムカテゴリも追加
        Array.from(customCategories).sort().forEach(cat => {
            if (!expenseCategories.includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `${cat} (その他)`;
                budgetCategorySelect.appendChild(opt);
            }
        });
    }

    async function updateBudgetStatus(monthlyDataPromise) {
        const monthlyData = await monthlyDataPromise; // Promiseを解決
        const budgets = await loadBudgets();
        budgetStatusDiv.innerHTML = '<h3>今月の予算実績</h3>';
        let hasBudget = false;

        const monthlyExpensesByCategory = {};
        monthlyData.filter(item => item.type === "支出").forEach(item => {
            // "その他"カテゴリでメモが使われていたらそのメモを実際のカテゴリとして使用
            const actualCategory = (item.category === "その他" && item.note && customCategories.has(item.note)) ? item.note : item.category;
            monthlyExpensesByCategory[actualCategory] = (monthlyExpensesByCategory[actualCategory] || 0) + item.amount;
        });

        for (const category in budgets) {
            hasBudget = true;
            const budgetAmount = budgets[category];
            const actualExpense = monthlyExpensesByCategory[category] || 0;
            const remaining = budgetAmount - actualExpense;
            const isWarning = remaining < 0;

            const budgetItem = document.createElement('div');
            budgetItem.className = `budget-item ${isWarning ? 'warning' : ''}`;
            budgetItem.innerHTML = `
                <span>${category}</span>
                <span>¥${actualExpense.toLocaleString()} / ¥${budgetAmount.toLocaleString()} (${remaining >= 0 ? '残り' : 'オーバー'} ¥${Math.abs(remaining).toLocaleString()})</span>
            `;
            budgetStatusDiv.appendChild(budgetItem);

            // 予算超過通知
            if (isWarning && Notification.permission === 'granted') {
                navigator.serviceWorker.ready.then(registration => {
                    registration.showNotification('予算オーバーのお知らせ', {
                        body: `${currentMonth.getFullYear()}年${currentMonth.getMonth() + 1}月 ${category} の予算が¥${Math.abs(remaining).toLocaleString()}オーバーしています！`,
                        icon: '/icon-192x192.png',
                        tag: `budget-over-${category}-${currentMonth.getFullYear()}-${currentMonth.getMonth()}`,
                        renotify: true // 同じタグの通知を更新
                    });
                });
            }
        }

        if (!hasBudget) {
            budgetStatusDiv.appendChild(noBudgetSetMessage);
        } else {
            if (budgetStatusDiv.contains(noBudgetSetMessage)) {
                noBudgetSetMessage.remove();
            }
        }
    }


    function initFilterCategorySelect() {
        const allCategories = new Set();
        CATEGORY_OPTIONS["支出"].forEach(cat => allCategories.add(cat));
        CATEGORY_OPTIONS["収入"].forEach(cat => allCategories.add(cat));
        customCategories.forEach(cat => allCategories.add(cat));

        filterCategorySelect.innerHTML = '<option value="">すべて</option>';
        Array.from(allCategories).sort().forEach(cat => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.textContent = cat;
            filterCategorySelect.appendChild(opt);
        });
    }

    searchBtn.addEventListener('click', loadAndDisplayData);
    resetFilterBtn.addEventListener('click', async () => {
        filterKeywordInput.value = '';
        filterTypeSelect.value = '';
        filterCategorySelect.value = '';
        filterAmountMinInput.value = '';
        filterAmountMaxInput.value = '';
        await loadAndDisplayData();
    });

    // --- 通知関連関数 ---
    function requestNotificationPermission() {
        if (!('Notification' in window)) {
            console.warn("このブラウザは通知をサポートしていません。");
            return;
        }

        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('通知許可が与えられました。');
                } else {
                    console.warn('通知許可が拒否されました。');
                }
            });
        }
    }

    function sendEndOfMonthReminder() {
        const today = new Date();
        const year = today.getFullYear();
        const month = today.getMonth(); // 0-indexed

        // 月末日を取得
        const lastDayOfMonth = new Date(year, month + 1, 0).getDate();

        // 今日が月の最終日だったら通知
        if (today.getDate() === lastDayOfMonth && Notification.permission === 'granted') {
            navigator.serviceWorker.ready.then(registration => {
                registration.showNotification('家計簿の締め日です！', {
                    body: '今月の家計簿記録を締め、来月の予算を確認しましょう。',
                    icon: '/icon-192x192.png',
                    tag: `end-of-month-reminder-${year}-${month}`,
                    renotify: false // 同じタグの通知は重複させない
                });
            });
        }
    }

    async function checkRecurringEntriesReminder() {
        const today = new Date();
        const currentMonth = today.getMonth();
        const currentYear = today.getFullYear();
        const recurringEntries = await loadAllDataFromStore(STORE_NAMES.RECURRING_ENTRIES);

        // 今月のエントリーを全て取得
        const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES);
        const thisMonthEntries = allEntries.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate.getFullYear() === currentYear && entryDate.getMonth() === currentMonth;
        });

        const missingRecurringEntries = [];

        for (const recurringItem of recurringEntries) {
            // その定期記録が今月すでに登録されているかチェック
            const alreadyAdded = thisMonthEntries.some(entry =>
                entry.type === recurringItem.type &&
                entry.category === recurringItem.category &&
                entry.amount === recurringItem.amount &&
                entry.date.startsWith(`${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}`)
            );

            if (!alreadyAdded) {
                missingRecurringEntries.push(recurringItem);
            }
        }

        if (missingRecurringEntries.length > 0 && Notification.permission === 'granted') {
            const bodyMessage = `今月まだ追加されていない定期的な記録があります: \n${missingRecurringEntries.map(item => `${item.category} (${item.type})`).join('\n')}`;
            navigator.serviceWorker.ready.then(registration => {
                registration.showNotification('定期的な記録の追加忘れ通知', {
                    body: bodyMessage,
                    icon: '/icon-192x192.png',
                    tag: `missing-recurring-entry-${currentYear}-${currentMonth}`,
                    renotify: true // 同じタグの通知を更新
                });
            });
        }
    }

    // --- 初期化関数 ---
    async function init() {
      await openDB();

      // Service Worker の登録
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js', { scope: '/' }) // スコープをルートに設定
            .then((registration) => {
              console.log('Service Worker registered: ', registration);
              // 通知許可を求める
              requestNotificationPermission();
            })
            .catch((error) => {
              console.log('Service Worker registration failed: ', error);
            });
        });
      }

      await loadAllDataForSuggestions(); // カテゴリ、メモ候補の初期ロード
      updateCategoryOptions();
      updateRecurringCategoryOptions();
      initFilterCategorySelect();
      initBudgetCategorySelect();
      await renderRecurringEntryList(); // 定期的な記録のリスト表示
      await renderBudgetList(); // 予算リストの表示
      await loadAndDisplayData(); // 履歴の表示と集計、グラフ更新
      updateMonthDisplay();

      // 通知のチェックを毎日行う（例: 午後10時）
      setInterval(() => {
          const now = new Date();
          if (now.getHours() === 22 && now.getMinutes() === 0) { // 毎日午後10時にチェック
              sendEndOfMonthReminder();
              checkRecurringEntriesReminder();
          }
      }, 60 * 1000); // 1分ごとにチェック
      sendEndOfMonthReminder(); // 起動時にもチェック
      checkRecurringEntriesReminder(); // 起動時にもチェック
    }

    // ページロード時に初期化
    init();

    // フッターナビゲーションのスクロール機能
    document.querySelectorAll('.footer-nav .nav-button').forEach(button => {
        button.addEventListener('click', (e) => {
            const targetId = e.currentTarget.dataset.target;
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
           <!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>家計簿アプリ</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="manifest" href="/manifest.json">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="家計簿">
  <link rel="apple-touch-icon" href="/icon-192x192.png">

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <link rel="icon" type="image/png" href="/icon-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/icon-512x512.png" sizes="512x512">

  <style>
    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      padding: 1.5em;
      padding-bottom: 60px; /* フッターナビゲーションの高さ分、下部に余白を追加 */
      max-width: 480px;
      margin: auto;
      background: #f0f2f5;
      color: #333;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 1.5em;
      font-size: 2em;
    }

    /* 各セクションの開始位置を示すためにIDにpadding-topとmargin-topを追加 */
    h2 {
      color: #2c3e50;
      margin-top: 2em;
      margin-bottom: 1em;
      padding-top: 60px; /* フッターの高さ分、paddingを追加して要素が隠れないように */
    }
    /* 最初のH2（固定支出の登録）はフォームの後なので、padding-topは不要 */
    h2:first-of-type {
        padding-top: 0;
    }


    form, .fixed-expense-section, .budget-section, .filter-section, .import-section, .recurring-entry-section { /* formに加えて新しいセクションにもスタイル適用 */
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 2em;
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    form label, .fixed-expense-section label, .budget-section label, .filter-section label, .import-section label, .recurring-entry-section label { /* 全てのラベルにスタイル適用 */
      display: block;
      margin-bottom: 0.8em;
      font-weight: bold;
    }

    form label input,
    form label select,
    .fixed-expense-section label input,
    .fixed-expense-section label select,
    .budget-section label input, /* 予算入力フィールド */
    .budget-section label select, /* 予算カテゴリ選択 */
    .filter-section label input, /* 検索入力フィールド */
    .filter-section label select,
    .import-section label input[type="file"], /* CSVインポートファイル入力フィールド */
    .recurring-entry-section label input,
    .recurring-entry-section label select {
      display: block;
      width: calc(100% - 1em);
      padding: 0.7em;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
      box-sizing: border-box;
      margin-top: 0.2em;
    }

    button[type="submit"], .add-fixed-expense-btn, #addMonthlyRecurringEntriesBtn,
    .budget-btn, #searchBtn, #resetFilterBtn, #importCsvBtn, .add-recurring-entry-btn { /* 全てのボタンの共通スタイル */
      background: #28a745;
      color: white;
      border: none;
      padding: 0.8em;
      cursor: pointer;
      margin-top: 0.5em;
      border-radius: 4px;
      transition: background 0.3s ease;
      width: 100%;
    }

    button[type="submit"]:hover, .add-fixed-expense-btn:hover, #addMonthlyRecurringEntriesBtn:hover,
    .budget-btn:hover, #searchBtn:hover, #resetFilterBtn:hover, #importCsvBtn:hover, .add-recurring-entry-btn:hover {
      background: #218838;
    }

    #searchBtn { background: #007bff; }
    #searchBtn:hover { background: #0056b3; }
    #resetFilterBtn { background: #6c757d; }
    #resetFilterBtn:hover { background: #5a6268; }
    #importCsvBtn { background: #007bff; } /* インポートボタンも青 */
    #importCsvBtn:hover { background: #0056b3; }


    ul {
      list-style: none;
      padding: 0;
    }

    /* 日付見出しのスタイル */
    .date-header {
      background-color: #e0e0e0;
      padding: 0.8em 1em;
      margin-top: 1.5em;
      margin-bottom: 0.5em;
      font-weight: bold;
      color: #555;
      border-bottom: 1px solid #ddd;
      border-radius: 4px 4px 0 0;
    }

    /* 各日のリストコンテナ */
    .daily-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* 各履歴アイテムのスタイル */
    .daily-list li {
      background: #ffffff;
      margin: 0.2em 0;
      padding: 0.8em 1em;
      border-left: 5px solid;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.05);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    /* 支出と収入のボーダー色 */
    .expense-item {
      border-color: #dc3545;
    }

    .income-item {
      border-color: #28a745;
    }

    /* 各項目詳細のスタイル */
    .item-details {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3em 0.8em;
      margin-right: 1em;
      align-items: baseline;
    }

    .item-type {
      font-weight: bold;
      color: #333;
      min-width: 45px;
      flex-shrink: 0;
    }
    .item-category {
      color: #333;
      font-weight: 500;
      min-width: 70px;
      flex-shrink: 0;
    }
    .item-amount {
      font-weight: bold;
      color: #000;
      margin-left: auto;
      font-size: 1.1em;
      flex-shrink: 0;
    }
    .item-note {
      font-size: 0.9em;
      color: #666;
      flex-basis: 100%;
      margin-top: 0.3em;
    }
    .item-tags { /* タグの表示スタイル */
      font-size: 0.8em;
      color: #007bff;
      flex-basis: 100%;
      margin-top: 0.3em;
    }

    /* 削除ボタンのスタイル */
    .delete-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 0.4em 0.8em;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      flex-shrink: 0;
      margin-left: 0.5em;
      align-self: center;
      transition: background 0.2s ease;
    }

    .delete-btn:hover {
      background: #c82333;
    }

    /* 月切り替えと分析セクション */
    .month-navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2em;
      margin-bottom: 1.5em;
      background: #ffffff;
      padding: 0.8em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      position: relative; /* monthPickerを絶対配置するため */
    }

    .month-navigation button {
      background: none;
      border: none;
      font-size: 1.5em;
      color: #2c3e50;
      cursor: pointer;
      padding: 0.2em 0.5em;
    }

    .month-display {
      font-size: 1.3em;
      font-weight: bold;
      color: #2c3e50;
      cursor: pointer; /* クリックできることを示す */
      text-decoration: underline; /* クリックできることを示す */
    }

    .summary-section {
      background: #ffffff;
      padding: 1.2em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      margin-bottom: 2em;
      text-align: center;
    }

    .summary-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5em;
      font-size: 1.1em;
    }
    .summary-item span:first-child {
      font-weight: bold;
    }
    .summary-item.income span:last-child { color: #28a745; }
    .summary-item.expense span:last-child { color: #dc3545; }
    .summary-item.total span:last-child { font-weight: bold; color: #2c3e50; }

    /* 予算表示のスタイル */
    .budget-status {
        margin-top: 1.5em;
        padding-top: 1em;
        border-top: 1px solid #eee;
    }
    .budget-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5em;
        font-size: 0.95em;
    }
    .budget-item.warning {
        color: #dc3545; /* 予算オーバー警告色 */
        font-weight: bold;
    }
    .budget-item span:first-child {
        font-weight: bold;
    }


    .chart-tabs {
      display: flex;
      justify-content: space-around;
      margin-bottom: 1.5em;
      background: #ffffff;
      padding: 0.5em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .chart-tabs button {
      flex: 1;
      padding: 0.8em 0.5em;
      border: none;
      background: none;
      font-size: 1em;
      cursor: pointer;
      color: #666;
      border-radius: 6px;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .chart-tabs button.active {
      background: #28a745;
      color: white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .chart-tabs button:hover:not(.active) {
      background: #f0f0f0;
    }

    .chart-container {
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 2em;
    }
    .chart-container canvas {
      max-width: 100%;
      height: auto;
    }

    /* CSVエクスポートボタンのスタイル */
    #exportCsvBtn {
        width: 100%;
        padding: 0.8em;
        background: #007bff; /* 青色 */
        color: white;
        border: none;
        cursor: pointer;
        margin-top: 1em;
        border-radius: 4px;
        transition: background 0.3s ease;
    }
    #exportCsvBtn:hover {
        background: #0056b3; /* ホバーで少し暗く */
    }

    /* 定期支出/収入リストのスタイル */
    #recurringEntryList {
        list-style: none;
        padding: 0;
    }
    #recurringEntryList li {
        background: #f8f8f8;
        padding: 0.8em 1em;
        margin-bottom: 0.5em;
        border-left: 5px solid; /* 種別によって色を変える */
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    #recurringEntryList li.expense-item { border-color: #dc3545; }
    #recurringEntryList li.income-item { border-color: #28a745; }

    #recurringEntryList li .delete-recurring-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 0.3em 0.6em;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7em;
        transition: background 0.2s ease;
    }
    #recurringEntryList li .delete-recurring-btn:hover {
        background: #c82333;
    }

    /* 検索フィルタリングセクション */
    .filter-section .filter-buttons {
        display: flex;
        gap: 0.5em;
    }
    .filter-section .filter-buttons button {
        flex: 1;
    }

    /* 入力候補リスト */
    .autocomplete-list {
        list-style: none;
        padding: 0;
        margin-top: 0.5em;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fff;
        max-height: 150px;
        overflow-y: auto;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        position: absolute; /* 親要素が relative であることを想定 */
        width: calc(100% - 3em); /* body padding 考慮 */
        z-index: 100; /* 他の要素より手前に表示 */
    }
    .autocomplete-list li {
        padding: 0.8em 1em;
        cursor: pointer;
        border-bottom: 1px solid #eee;
    }
    .autocomplete-list li:last-child {
        border-bottom: none;
    }
    .autocomplete-list li:hover {
        background-color: #f0f0f0;
    }

    .form-group-relative {
        position: relative;
    }

    /* --- 新しいCSS: フッターナビゲーション --- */
    .footer-nav {
        position: fixed; /* 画面下部に固定 */
        bottom: 0; /* 下端に配置 */
        left: 0;
        width: 100%;
        max-width: 480px; /* bodyのmax-widthに合わせる */
        left: 50%;
        transform: translateX(-50%); /* 中央揃え */
        background: #343a40; /* ダーク系の背景色 */
        display: flex;
        justify-content: space-around;
        padding: 8px 0;
        box-shadow: 0 -2px 8px rgba(0,0,0,0.2); /* 上部に影 */
        z-index: 1000; /* 他の要素より手前に表示 */
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }

    .footer-nav button {
        background: none;
        border: none;
        color: white;
        font-size: 0.8em;
        padding: 0.5em 0.2em;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        flex: 1; /* 等幅で配置 */
        transition: color 0.2s ease;
    }

    .footer-nav button:hover {
        color: #28a745; /* ホバーでアクセントカラー */
    }

    /* アイコン部分のスタイル (Material Iconsなどを使う場合はフォントサイズで調整) */
    .footer-nav button i {
        font-size: 1.4em; /* アイコンのサイズ */
        margin-bottom: 3px;
    }
  </style>
</head>
<body>
  <h1 id="top">家計簿</h1>
  <form id="expense-form">
    <label>種別：
      <select id="type" required>
        <option value="">選択してください</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>

    <label>日付：
      <input type="date" id="date" required />
    </label>

    <label>カテゴリ：
      <select id="category" required>
        <option value="">まず種別を選んでください</option>
      </select>
    </label>

    <label>金額（円）：
      <input type="number" id="amount" required min="0" />
    </label>

    <label class="form-group-relative">メモ：
      <input type="text" id="note" list="memo-suggestions" />
      <datalist id="memo-suggestions"></datalist>
    </label>

    <label>タグ（カンマ区切り）：
      <input type="text" id="tags" placeholder="例: 食事,外食,ランチ" />
    </label>

    <button type="submit">追加</button>
  </form>

  <h2>CSVデータのインポート</h2>
  <div class="import-section">
    <label for="csvFileInput">
      CSVファイルを選択してインポート:
      <input type="file" id="csvFileInput" accept=".csv"/>
    </label>
    <button type="button" id="importCsvBtn">CSVをインポート</button>
  </div>

  <h2 id="budget-section-h2">予算設定</h2>
  <div class="budget-section">
    <h3>月間予算を設定</h3>
    <label>カテゴリ：
      <select id="budgetCategorySelect" required>
        </select>
    </label>
    <label>予算額（円）：
      <input type="number" id="budgetAmountInput" required min="0" />
    </label>
    <button type="button" id="setBudgetBtn" class="budget-btn">予算を設定</button>

    <h3>現在の予算設定</h3>
    <ul id="budgetList">
      </ul>
  </div>

  <h2 id="recurring-entry-section-h2">定期的な記録の登録</h2>
  <div class="recurring-entry-section">
    <label>種別：
      <select id="recurringType" required>
        <option value="">選択してください</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>
    <label>カテゴリ：
      <select id="recurringCategory" required>
        </select>
    </label>
    <label>金額（円）：
      <input type="number" id="recurringAmount" required min="0" />
    </label>
    <label>メモ：
      <input type="text" id="recurringNote" />
    </label>
    <label>追加日（毎月）：
      <input type="number" id="recurringDay" required min="1" max="31" placeholder="例: 25 (毎月25日)" />
    </label>
    <button type="button" id="addRecurringEntryBtn" class="add-recurring-entry-btn">定期的な記録を登録</button>

    <h3>登録済みの定期的な記録</h3>
    <ul id="recurringEntryList">
      </ul>
    <button type="button" id="addMonthlyRecurringEntriesBtn">今月に定期的な記録を一括追加</button>
  </div>


  <h2 id="history-section-h2">履歴</h2>
  <div class="month-navigation">
    <button id="prevMonth">&lt;</button>
    <span id="currentMonthDisplay" class="month-display"></span>
    <input type="month" id="monthPicker" style="opacity: 0; pointer-events: none; position: absolute; width: 1px; height: 1px;">
    <button id="nextMonth">&gt;</button>
  </div>

  <div class="filter-section">
    <h3>履歴の検索・絞り込み</h3>
    <label>キーワード（メモ・タグ）：
      <input type="search" id="filterKeyword" placeholder="例: ランチ, #旅行" />
    </label>
    <label>種別：
      <select id="filterType">
        <option value="">すべて</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>
    <label>カテゴリ：
      <select id="filterCategory">
        <option value="">すべて</option>
        </select>
    </label>
    <label>金額（下限）：
      <input type="number" id="filterAmountMin" min="0" />
    </label>
    <label>金額（上限）：
      <input type="number" id="filterAmountMax" min="0" />
    </label>
    <div class="filter-buttons">
        <button type="button" id="searchBtn">検索</button>
        <button type="button" id="resetFilterBtn">リセット</button>
    </div>
  </div>

  <ul id="history"></ul>

  <button id="exportCsvBtn">CSVでエクスポート</button>

  <h2 id="analysis-section-h2">分析</h2>
  <div class="summary-section">
    <div class="summary-item income">
      <span>収入</span><span id="totalIncome">¥0</span>
    </div>
    <div class="summary-item expense">
      <span>支出</span><span id="totalExpense">¥0</span>
    </div>
    <hr style="margin: 1em 0; border: none; border-top: 1px solid #eee;">
    <div class="summary-item total">
      <span>合計</span><span id="balance">¥0</span>
    </div>
    <div class="budget-status" id="budgetStatus">
        <h3>今月の予算実績</h3>
        <p style="text-align: center; color: #777; font-size: 0.9em;" id="noBudgetSetMessage">予算が設定されていません。</p>
        </div>
  </div>

  <div class="chart-tabs">
    <button id="pieChartTab" class="active">カテゴリ別（円グラフ）</button>
    <button id="monthlyBarChartTab">月別推移（棒グラフ）</button>
    <button id="yearlyBarChartTab">年別推移（棒グラフ）</button>
  </div>

  <div class="chart-container">
    <canvas id="myChart"></canvas>
  </div>

  <div class="footer-nav">
    <button class="nav-button" data-target="top">
        <i class="material-icons">add_circle_outline</i>
        <span>入力</span>
    </button>
    <button class="nav-button" data-target="budget-section-h2">
        <i class="material-icons">account_balance_wallet</i>
        <span>予算</span>
    </button>
    <button class="nav-button" data-target="recurring-entry-section-h2">
        <i class="material-icons">event_note</i>
        <span>定期</span>
    </button>
    <button class="nav-button" data-target="history-section-h2">
        <i class="material-icons">history</i>
        <span>履歴</span>
    </button>
    <button class="nav-button" data-target="analysis-section-h2">
        <i class="material-icons">bar_chart</i>
        <span>分析</span>
    </button>
  </div>

  <script>
    // 定数定義
    const CACHE_NAME = 'kakeibo-app-cache-v2'; // キャッシュバージョンを更新
    const DB_NAME = 'kakeiboDB';
    const DB_VERSION = 1;
    const STORE_NAMES = {
        ENTRIES: 'entries',
        RECURRING_ENTRIES: 'recurringEntries', // fixedExpenses から recurringEntries に変更
        BUDGETS: 'budgets'
    };
    const CATEGORY_OPTIONS = {
      "支出": [
        "食費", "日用品", "住居", "光熱費", "通信費", "保険", "医療費",
        "被服・美容", "交通", "教育・書籍", "娯楽・交際", "サブスク",
        "税金・年金", "その他"
      ],
      "収入": [
        "給与", "副業", "お小遣い", "配当・投資", "賞与", "その他"
      ]
    };
    const NOTIFICATION_CHANNEL_ID = 'kakeibo-notifications';

    // DOM要素の取得
    const form = document.getElementById("expense-form");
    const historyList = document.getElementById("history");
    const typeSelect = document.getElementById("type");
    const categorySelect = document.getElementById("category");
    const amountInput = document.getElementById("amount");
    const noteInput = document.getElementById("note");
    const tagsInput = document.getElementById("tags");
    const currentMonthDisplay = document.getElementById("currentMonthDisplay");
    const prevMonthBtn = document.getElementById("prevMonth");
    const nextMonthBtn = document.getElementById("nextMonth");
    const totalIncomeSpan = document.getElementById("totalIncome");
    const totalExpenseSpan = document.getElementById("totalExpense");
    const balanceSpan = document.getElementById("balance");
    const pieChartTab = document.getElementById("pieChartTab");
    const monthlyBarChartTab = document.getElementById("monthlyBarChartTab"); // 新しいタブ
    const yearlyBarChartTab = document.getElementById("yearlyBarChartTab");   // 新しいタブ
    const myChartCanvas = document.getElementById("myChart");
    const exportCsvBtn = document.getElementById("exportCsvBtn");
    const csvFileInput = document.getElementById("csvFileInput");
    const importCsvBtn = document.getElementById("importCsvBtn");
    const monthPicker = document.getElementById("monthPicker");

    // 定期的な記録関連のDOM要素 (旧fixed-expense)
    const recurringTypeSelect = document.getElementById("recurringType");
    const recurringCategorySelect = document.getElementById("recurringCategory");
    const recurringAmountInput = document.getElementById("recurringAmount");
    const recurringNoteInput = document.getElementById("recurringNote");
    const recurringDayInput = document.getElementById("recurringDay");
    const addRecurringEntryBtn = document.getElementById("addRecurringEntryBtn");
    const recurringEntryList = document.getElementById("recurringEntryList");
    const addMonthlyRecurringEntriesBtn = document.getElementById("addMonthlyRecurringEntriesBtn");

    // 予算設定関連のDOM要素
    const budgetCategorySelect = document.getElementById("budgetCategorySelect");
    const budgetAmountInput = document.getElementById("budgetAmountInput");
    const setBudgetBtn = document.getElementById("setBudgetBtn");
    const budgetList = document.getElementById("budgetList");
    const budgetStatusDiv = document.getElementById("budgetStatus");
    const noBudgetSetMessage = document.getElementById("noBudgetSetMessage");

    // フィルタリング・検索関連のDOM要素
    const filterKeywordInput = document.getElementById("filterKeyword");
    const filterTypeSelect = document.getElementById("filterType");
    const filterCategorySelect = document.getElementById("filterCategory");
    const filterAmountMinInput = document.getElementById("filterAmountMin");
    const filterAmountMaxInput = document.getElementById("filterAmountMax");
    const searchBtn = document.getElementById("searchBtn");
    const resetFilterBtn = document.getElementById("resetFilterBtn");
    const memoSuggestionsDatalist = document.getElementById("memo-suggestions");


    // グローバル変数
    let customCategories = new Set();
    let pastNotes = new Set();
    let currentMonth = new Date();
    let myChartInstance;
    let db; // IndexedDBインスタンス

    // --- IndexedDB関連関数 ---
    async function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAMES.ENTRIES)) {
                    const entriesStore = db.createObjectStore(STORE_NAMES.ENTRIES, { keyPath: 'id', autoIncrement: true });
                    entriesStore.createIndex('date', 'date', { unique: false });
                    entriesStore.createIndex('type', 'type', { unique: false });
                    entriesStore.createIndex('category', 'category', { unique: false });
                    entriesStore.createIndex('note', 'note', { unique: false });
                    entriesStore.createIndex('tags', 'tags', { unique: false });
                }
                // 固定支出ストアの名前を recurringEntries に変更、dayIndex を追加
                if (!db.objectStoreNames.contains(STORE_NAMES.RECURRING_ENTRIES)) {
                    const recurringStore = db.createObjectStore(STORE_NAMES.RECURRING_ENTRIES, { keyPath: 'id', autoIncrement: true });
                    recurringStore.createIndex('type', 'type', { unique: false });
                    recurringStore.createIndex('category', 'category', { unique: false });
                    recurringStore.createIndex('day', 'day', { unique: false }); // 追加日用インデックス
                }
                if (!db.objectStoreNames.contains(STORE_NAMES.BUDGETS)) {
                    db.createObjectStore(STORE_NAMES.BUDGETS, { keyPath: 'category' });
                }
                console.log('IndexedDB upgraded or created successfully.');
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('IndexedDB opened successfully.');
                resolve(db);
            };

            request.onerror = (event) => {
                console.error('IndexedDB error:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function saveData(storeName, data) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);

            const request = store.put(data);

            request.onsuccess = () => {
                // console.log(`Data saved to IndexedDB (${storeName}):`, data);
                resolve();
            };

            request.onerror = (event) => {
                console.error(`Error saving data to IndexedDB (${storeName}):`, event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function loadAllDataFromStore(storeName) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = (event) => {
                resolve(event.target.result);
            };

            request.onerror = (event) => {
                console.error(`Error loading data from IndexedDB (${storeName}):`, event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function deleteDataFromStore(storeName, id) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);

            request.onsuccess = () => {
                console.log(`Data deleted from IndexedDB (${storeName}):`, id);
                resolve();
            };

            request.onerror = (event) => {
                console.error(`Error deleting data from IndexedDB (${storeName}):`, event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    // --- メインアプリロジック ---
    document.getElementById("date").valueAsDate = new Date();
    typeSelect.addEventListener("change", updateCategoryOptions);
    recurringTypeSelect.addEventListener("change", updateRecurringCategoryOptions);


    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const data = {
        type: typeSelect.value,
        date: document.getElementById("date").value,
        category: categorySelect.value,
        amount: parseInt(amountInput.value, 10),
        note: noteInput.value,
        tags: tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '')
      };

      if (!data.type || !data.date || !data.category || isNaN(data.amount) || data.amount <= 0) {
        alert("種別、日付、カテゴリ、金額は必須入力です。金額は正の数値を入力してください。");
        return;
      }

      if (data.category === "その他" && data.note) {
          customCategories.add(data.note);
      }
      if (data.note) {
          pastNotes.add(data.note);
      }

      await saveData(STORE_NAMES.ENTRIES, data);
      await loadAndDisplayData();
      form.reset();
      updateCategoryOptions();
      updateMemoSuggestions();
    });

    function updateCategoryOptions() {
      const type = typeSelect.value;
      categorySelect.innerHTML = '<option value="">選択してください</option>';

      if (CATEGORY_OPTIONS[type]) {
        CATEGORY_OPTIONS[type].forEach(cat => {
          const opt = document.createElement("option");
          opt.value = cat;
          opt.textContent = cat;
          categorySelect.appendChild(opt);
        });
      } else {
        categorySelect.innerHTML = '<option value="">まず種別を選んでください</option>';
      }

      // カスタムカテゴリを追加
      Array.from(customCategories).sort().forEach(cat => {
          if (!CATEGORY_OPTIONS["支出"].includes(cat) && !CATEGORY_OPTIONS["収入"].includes(cat)) {
              const opt = document.createElement("option");
              opt.value = cat;
              opt.textContent = `${cat} (その他)`;
              categorySelect.appendChild(opt);
          }
      });
    }

    function updateRecurringCategoryOptions() {
        const type = recurringTypeSelect.value;
        recurringCategorySelect.innerHTML = '<option value="">選択してください</option>';

        if (CATEGORY_OPTIONS[type]) {
            CATEGORY_OPTIONS[type].forEach(cat => {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = cat;
                recurringCategorySelect.appendChild(opt);
            });
        }
        // カスタムカテゴリも追加
        Array.from(customCategories).sort().forEach(cat => {
            if (type === '支出' && !CATEGORY_OPTIONS["支出"].includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `${cat} (その他)`;
                recurringCategorySelect.appendChild(opt);
            } else if (type === '収入' && !CATEGORY_OPTIONS["収入"].includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `${cat} (その他)`;
                recurringCategorySelect.appendChild(opt);
            }
        });
    }

    function updateMemoSuggestions() {
        memoSuggestionsDatalist.innerHTML = '';
        pastNotes.forEach(note => {
            const option = document.createElement('option');
            option.value = note;
            memoSuggestionsDatalist.appendChild(option);
        });
    }

    async function loadAllDataForSuggestions() {
        const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        customCategories.clear();
        pastNotes.clear();

        allEntries.forEach(item => {
            // "その他"カテゴリでメモが使われていたらカスタムカテゴリとして記憶
            if (item.category === "その他" && item.note) {
                customCategories.add(item.note);
            } else if (!CATEGORY_OPTIONS["支出"].includes(item.category) && !CATEGORY_OPTIONS["収入"].includes(item.category)) {
                // 定義済みカテゴリになく、メモがある場合もカスタムカテゴリとして記憶
                customCategories.add(item.category);
            }
            if (item.note) {
                pastNotes.add(item.note);
            }
        });
        updateCategoryOptions();
        updateRecurringCategoryOptions(); // 定期的な記録のカテゴリも更新
        updateMemoSuggestions();
    }

    async function loadAndDisplayData() {
        let allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        historyList.innerHTML = "";

        const filterKeyword = filterKeywordInput.value.toLowerCase();
        const filterType = filterTypeSelect.value;
        const filterCategory = filterCategorySelect.value;
        const filterAmountMin = parseInt(filterAmountMinInput.value, 10);
        const filterAmountMax = parseInt(filterAmountMaxInput.value, 10);

        const filteredData = allEntries.filter(item => {
            const keywordMatch = !filterKeyword ||
                                  (item.note && item.note.toLowerCase().includes(filterKeyword)) ||
                                  (item.tags && item.tags.some(tag => tag.toLowerCase().includes(filterKeyword)));

            const typeMatch = !filterType || item.type === filterType;
            const categoryMatch = !filterCategory || item.category === filterCategory;
            const amountMatch = (isNaN(filterAmountMin) || item.amount >= filterAmountMin) &&
                                 (isNaN(filterAmountMax) || item.amount <= filterAmountMax);

            return keywordMatch && typeMatch && categoryMatch && amountMatch;
        });

        const currentMonthYear = currentMonth.getFullYear();
        const currentMonthMonth = currentMonth.getMonth();

        const monthlyData = filteredData.filter(item => {
            const itemDate = new Date(item.date);
            // Dateオブジェクトのパースは 'YYYY-MM-DD' 形式を推奨
            const [year, month, day] = item.date.split('-').map(Number);
            const itemParsedDate = new Date(year, month - 1, day); // 月は0始まり

            return itemParsedDate.getFullYear() === currentMonthYear && itemParsedDate.getMonth() === currentMonthMonth;
        });

        monthlyData.sort((a, b) => {
            const dateA = new Date(a.date);
            const dateB = new Date(b.date);
            if (dateA.getTime() === dateB.getTime()) {
                // 日付が同じ場合はタイプ（支出優先）と金額でソート
                if (a.type === "支出" && b.type === "収入") return -1;
                if (a.type === "収入" && b.type === "支出") return 1;
                return b.amount - a.amount; // 金額降順
            }
            return dateB - dateA; // 日付降順
        });


        const groupedData = {};
        monthlyData.forEach(item => {
            if (!groupedData[item.date]) {
                groupedData[item.date] = [];
            }
            groupedData[item.date].push(item);
        });

        if (Object.keys(groupedData).length === 0) {
            historyList.innerHTML = '<p style="text-align: center; color: #777; margin-top: 2em;">この月には履歴がありません。</p>';
            if (filterKeyword || filterType || filterCategory || !isNaN(filterAmountMin) || !isNaN(filterAmountMax)) {
                historyList.innerHTML += '<p style="text-align: center; color: #777; font-size: 0.9em;">（検索条件に合う項目が見つかりませんでした）</p>';
            }
        } else {
            for (const date in groupedData) {
                if (groupedData.hasOwnProperty(date)) {
                    const dailyItems = groupedData[date];

                    const dateHeader = document.createElement("div");
                    dateHeader.className = "date-header";
                    const [year, month, day] = date.split('-');
                    const dayOfWeek = new Date(year, month - 1, day).toLocaleDateString('ja-JP', { weekday: 'short' });
                    const formattedDate = `${year}年${parseInt(month)}月${parseInt(day)}日 (${dayOfWeek})`;

                    dateHeader.textContent = formattedDate;
                    historyList.appendChild(dateHeader);

                    const ul = document.createElement("ul");
                    ul.className = "daily-list";

                    dailyItems.forEach((item) => {
                        const li = document.createElement("li");
                        li.className = item.type === "支出" ? "expense-item" : "income-item";
                        li.innerHTML = `
                            <span class="item-details">
                              <span class="item-type">${item.type}</span>
                              <span class="item-category">${item.category}</span>
                              <span class="item-amount">¥${item.amount.toLocaleString()}</span>
                              ${item.note ? `<span class="item-note">${item.note}</span>` : ''}
                              ${item.tags && item.tags.length > 0 ? `<span class="item-tags">${item.tags.map(tag => `#${tag}`).join(' ')}</span>` : ''}
                            </span>
                            <button class="delete-btn" data-id="${item.id}" data-store="${STORE_NAMES.ENTRIES}">削除</button>
                        `;
                        ul.appendChild(li);
                    });
                    historyList.appendChild(ul);
                }
            }
        }

        document.querySelectorAll('.delete-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const idToDelete = parseInt(e.target.dataset.id, 10);
                const storeName = e.target.dataset.store;
                if (confirm("この項目を削除してもよろしいですか？")) {
                    await deleteDataFromStore(storeName, idToDelete);
                    await loadAndDisplayData();
                    await loadAllDataForSuggestions();
                }
            });
        });

        updateMonthDisplay();
        updateSummary(monthlyData);
        await updateCharts(); // await を追加
        updateBudgetStatus(monthlyData);
    }


    function updateMonthDisplay() {
      const year = currentMonth.getFullYear();
      const month = currentMonth.getMonth() + 1;
      currentMonthDisplay.textContent = `${year}年${month}月`;
      monthPicker.value = `${year}-${month.toString().padStart(2, '0')}`;
    }

    currentMonthDisplay.addEventListener('click', () => {
        monthPicker.click();
    });

    monthPicker.addEventListener('change', async () => {
        const [year, month] = monthPicker.value.split('-').map(Number);
        currentMonth.setFullYear(year, month - 1, 1);
        await loadAndDisplayData();
    });

    prevMonthBtn.addEventListener("click", async () => {
      currentMonth.setMonth(currentMonth.getMonth() - 1);
      await loadAndDisplayData();
    });

    nextMonthBtn.addEventListener("click", async () => {
      currentMonth.setMonth(currentMonth.getMonth() + 1);
      await loadAndDisplayData();
    });


    function updateSummary(data) {
      let totalIncome = 0;
      let totalExpense = 0;

      data.forEach(item => {
        if (item.type === "収入") {
          totalIncome += item.amount;
        } else if (item.type === "支出") {
          totalExpense += item.amount;
        }
      });

      totalIncomeSpan.textContent = `¥${totalIncome.toLocaleString()}`;
      totalExpenseSpan.textContent = `¥${totalExpense.toLocaleString()}`;
      balanceSpan.textContent = `¥${(totalIncome - totalExpense).toLocaleString()}`;
    }

    // --- グラフ関連 ---
    async function updateCharts() {
      if (myChartInstance) {
        myChartInstance.destroy();
      }

      const activeTab = document.querySelector('.chart-tabs button.active').id;
      const monthlyData = await filterAndSortMonthlyData(); // 月別データ取得
      const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || []; // 全データ取得

      if (activeTab === 'pieChartTab') {
        renderPieChart(monthlyData);
      } else if (activeTab === 'monthlyBarChartTab') {
        renderMonthlyBarChart(allEntries);
      } else if (activeTab === 'yearlyBarChartTab') {
        renderYearlyBarChart(allEntries); // 新しいグラフの描画
      }
    }

    function renderPieChart(monthlyData) {
      const expenseByCategory = {};
      monthlyData.filter(item => item.type === "支出").forEach(item => {
        // カスタムカテゴリを考慮
        const actualCategory = (item.category === "その他" && item.note && customCategories.has(item.note)) ? item.note : item.category;
        expenseByCategory[actualCategory] = (expenseByCategory[actualCategory] || 0) + item.amount;
      });

      const labels = Object.keys(expenseByCategory);
      const dataValues = Object.values(expenseByCategory);
      const backgroundColors = generateColors(labels.length);

      myChartInstance = new Chart(myChartCanvas, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: dataValues,
            backgroundColor: backgroundColors,
            hoverOffset: 4
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            },
            title: {
              display: true,
              text: '月間支出カテゴリ別内訳'
            }
          }
        }
      });
    }

    function renderMonthlyBarChart(allData) {
        const monthlySummary = {};

        allData.forEach(item => {
            const [year, month] = item.date.split('-').map(Number);
            const yearMonth = `${year}-${month.toString().padStart(2, '0')}`;

            if (!monthlySummary[yearMonth]) {
                monthlySummary[yearMonth] = { income: 0, expense: 0 };
            }

            if (item.type === "収入") {
                monthlySummary[yearMonth].income += item.amount;
            } else if (item.type === "支出") {
                monthlySummary[yearMonth].expense += item.amount;
            }
        });

        const sortedMonths = Object.keys(monthlySummary).sort();

        const incomes = sortedMonths.map(month => monthlySummary[month].income);
        const expenses = sortedMonths.map(month => monthlySummary[month].expense);

        myChartInstance = new Chart(myChartCanvas, {
            type: 'bar',
            data: {
                labels: sortedMonths,
                datasets: [
                    {
                        label: '収入',
                        data: incomes,
                        backgroundColor: 'rgba(40, 167, 69, 0.7)',
                        borderColor: 'rgba(40, 167, 69, 1)',
                        borderWidth: 1
                    },
                    {
                        label: '支出',
                        data: expenses,
                        backgroundColor: 'rgba(220, 53, 69, 0.7)',
                        borderColor: 'rgba(220, 53, 69, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: '月別収支推移'
                    }
                },
                scales: {
                    x: {
                        stacked: false
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false
                    }
                }
            }
        });
    }

    // 新しいグラフ: 年別収支推移の棒グラフ
    function renderYearlyBarChart(allData) {
        const yearlySummary = {};

        allData.forEach(item => {
            const [year] = item.date.split('-').map(Number);
            const yearString = String(year);

            if (!yearlySummary[yearString]) {
                yearlySummary[yearString] = { income: 0, expense: 0 };
            }

            if (item.type === "収入") {
                yearlySummary[yearString].income += item.amount;
            } else if (item.type === "支出") {
                yearlySummary[yearString].expense += item.amount;
            }
        });

        const sortedYears = Object.keys(yearlySummary).sort();

        const incomes = sortedYears.map(year => yearlySummary[year].income);
        const expenses = sortedYears.map(year => yearlySummary[year].expense);

        myChartInstance = new Chart(myChartCanvas, {
            type: 'bar',
            data: {
                labels: sortedYears,
                datasets: [
                    {
                        label: '収入',
                        data: incomes,
                        backgroundColor: 'rgba(40, 167, 69, 0.7)',
                        borderColor: 'rgba(40, 167, 69, 1)',
                        borderWidth: 1
                    },
                    {
                        label: '支出',
                        data: expenses,
                        backgroundColor: 'rgba(220, 53, 69, 0.7)',
                        borderColor: 'rgba(220, 53, 69, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: '年別収支推移'
                    }
                },
                scales: {
                    x: {
                        stacked: false
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false
                    }
                }
            }
        });
    }


    function generateColors(numColors) {
      const colors = [];
      const hueStep = 360 / numColors;
      for (let i = 0; i < numColors; i++) {
        const hue = i * hueStep;
        colors.push(`hsl(${hue}, 70%, 60%)`);
      }
      return colors;
    }

    pieChartTab.addEventListener('click', async () => {
      document.querySelectorAll('.chart-tabs button').forEach(btn => btn.classList.remove('active'));
      pieChartTab.classList.add('active');
      await updateCharts();
    });

    monthlyBarChartTab.addEventListener('click', async () => {
      document.querySelectorAll('.chart-tabs button').forEach(btn => btn.classList.remove('active'));
      monthlyBarChartTab.classList.add('active');
      await updateCharts();
    });

    yearlyBarChartTab.addEventListener('click', async () => {
      document.querySelectorAll('.chart-tabs button').forEach(btn => btn.classList.remove('active'));
      yearlyBarChartTab.classList.add('active');
      await updateCharts();
    });


    async function filterAndSortMonthlyData() {
        const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        const currentMonthYear = currentMonth.getFullYear();
        const currentMonthMonth = currentMonth.getMonth();

        return allEntries.filter(item => {
            const [year, month, day] = item.date.split('-').map(Number);
            const itemDate = new Date(year, month - 1, day);
            return itemDate.getFullYear() === currentMonthYear && itemDate.getMonth() === currentMonthMonth;
        });
    }


    exportCsvBtn.addEventListener('click', async () => {
        const allData = await loadAllDataFromStore(STORE_NAMES.ENTRIES) || [];
        if (allData.length === 0) {
            alert("エクスポートするデータがありません。");
            return;
        }

        const headers = ["日付", "種別", "カテゴリ", "金額", "メモ", "タグ"];
        const csvRows = allData.map(item => {
            const escapeCsv = (value) => {
                if (value === null || value === undefined) return '';
                let stringValue = String(value);
                if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                    return `"${stringValue.replace(/"/g, '""')}"`;
                }
                return stringValue;
            };

            const tagsString = item.tags ? item.tags.join(',') : '';
            return [
                escapeCsv(item.date),
                escapeCsv(item.type),
                escapeCsv(item.category),
                escapeCsv(item.amount),
                escapeCsv(item.note),
                escapeCsv(tagsString)
            ].join(',');
        });

        const csvContent = [headers.join(','), ...csvRows].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

        const link = document.createElement('a');
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', '家計簿データ.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("お使いのブラウザはCSVエクスポートに対応していません。");
        }
    });

    importCsvBtn.addEventListener('click', () => {
        const file = csvFileInput.files[0];
        if (!file) {
            alert("CSVファイルを選択してください。");
            return;
        }

        if (!confirm("CSVファイルをインポートしますか？既存のデータに**追加**されます。（同じ内容が重複する可能性があります）")) {
            return;
        }

        const reader = new FileReader();

        reader.onload = async (e) => {
            const csvText = e.target.result;
            try {
                await parseAndImportCsv(csvText);
                alert("CSVデータのインポートが完了しました！");
                csvFileInput.value = '';
                await loadAndDisplayData();
                await loadAllDataForSuggestions();
            } catch (error) {
                console.error("CSVインポートエラー:", error);
                alert("CSVファイルの読み込み中にエラーが発生しました。ファイル形式を確認してください。\n" + error.message);
            }
        };

        reader.onerror = (e) => {
            console.error("ファイル読み込みエラー:", e);
            alert("ファイルの読み込み中にエラーが発生しました。");
        };

        reader.readAsText(file, 'UTF-8');
    });

    async function parseAndImportCsv(csvText) {
        const lines = csvText.trim().split('\n').slice(1);

        if (lines.length === 0) {
            console.warn("CSVファイルにデータ行がありません。");
            return;
        }

        for (const line of lines) {
            const values = line.match(/(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|([^,]*))(?:,|$)/g)
                               .map(match => {
                                   let val = match.endsWith(',') ? match.slice(0, -1) : match;
                                   if (val.startsWith('"') && val.endsWith('"')) {
                                       val = val.slice(1, -1).replace(/\"\"/g, '\"');
                                   }
                                   return val;
                               }).filter(val => val !== "");

            if (values.length >= 4) {
                const type = values[1];
                const date = values[0];
                const category = values[2];
                const amount = parseInt(values[3], 10);
                const note = values[4] || '';
                const tagsString = values[5] || '';
                const tags = tagsString ? tagsString.split(',').map(tag => tag.trim()).filter(t => t !== '') : [];

                if (!type || !date || !category || isNaN(amount) || amount < 0) { // 金額は0以上を許容
                    console.warn("不正なデータ形式の行をスキップしました:", line);
                    continue;
                }

                // 日付の形式チェック (YYYY-MM-DD)
                if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                    console.warn("不正な日付形式の行をスキップしました:", line);
                    continue;
                }
                const parsedDate = new Date(date);
                if (isNaN(parsedDate.getTime())) {
                    console.warn("無効な日付の行をスキップしました:", line);
                    continue;
                }

                const data = { type, date, category, amount, note, tags };
                await saveData(STORE_NAMES.ENTRIES, data);
            } else {
                console.warn("列数が足りない行をスキップしました:", line);
            }
        }
    }

    // --- 定期的な記録機能 (旧 固定支出) ---
    async function renderRecurringEntryList() {
        const recurringEntries = await loadAllDataFromStore(STORE_NAMES.RECURRING_ENTRIES);
        recurringEntryList.innerHTML = '';
        if (recurringEntries.length === 0) {
            recurringEntryList.innerHTML = '<p style="text-align: center; color: #777; font-size: 0.9em;">登録済みの定期的な記録はありません。</p>';
            return;
        }
        recurringEntries.forEach((item) => {
            const li = document.createElement('li');
            li.className = item.type === "支出" ? "expense-item" : "income-item";
            li.innerHTML = `
                <span>${item.type}・${item.category}: ¥${item.amount.toLocaleString()} (毎月 ${item.day}日) ${item.note ? `(${item.note})` : ''}</span>
                <button class="delete-recurring-btn" data-id="${item.id}" data-store="${STORE_NAMES.RECURRING_ENTRIES}">削除</button>
            `;
            recurringEntryList.appendChild(li);
        });

        document.querySelectorAll('.delete-recurring-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const idToDelete = parseInt(e.target.dataset.id, 10);
                const storeName = e.target.dataset.store;
                if (confirm("この定期的な記録を削除してもよろしいですか？")) {
                    await deleteDataFromStore(storeName, idToDelete);
                    renderRecurringEntryList();
                }
            });
        });
    }

    addRecurringEntryBtn.addEventListener('click', async () => {
        const type = recurringTypeSelect.value;
        const category = recurringCategorySelect.value;
        const amount = parseInt(recurringAmountInput.value, 10);
        const note = recurringNoteInput.value;
        const day = parseInt(recurringDayInput.value, 10);

        if (!type || !category || isNaN(amount) || amount <= 0 || isNaN(day) || day < 1 || day > 31) {
            alert("種別、カテゴリ、金額、追加日（1-31）は必須入力です。金額は正の数値を入力してください。");
            return;
        }

        const data = { type, category, amount, note, day };
        await saveData(STORE_NAMES.RECURRING_ENTRIES, data);
        renderRecurringEntryList();
        recurringAmountInput.value = '';
        recurringNoteInput.value = '';
        recurringTypeSelect.value = '';
        recurringCategorySelect.value = '';
        recurringDayInput.value = '';
        updateRecurringCategoryOptions(); // カテゴリ選択をリセット
    });

    addMonthlyRecurringEntriesBtn.addEventListener('click', async () => {
        const recurringEntries = await loadAllDataFromStore(STORE_NAMES.RECURRING_ENTRIES);
        if (recurringEntries.length === 0) {
            alert("登録済みの定期的な記録がありません。");
            return;
        }

        if (!confirm("今月に登録済みの定期的な記録をすべて追加しますか？（重複登録にご注意ください）")) {
            return;
        }

        const today = new Date();
        const year = today.getFullYear();
        const month = (today.getMonth() + 1).toString().padStart(2, '0');

        let addedCount = 0;
        for (const recurringItem of recurringEntries) {
            const day = recurringItem.day.toString().padStart(2, '0');
            const dateString = `${year}-${month}-${day}`;

            // 月末の日付を超える場合は月末に調整
            const checkDate = new Date(dateString);
            if (checkDate.getMonth() !== today.getMonth()) { // 例えば2/30のような日付の場合
                const lastDayOfMonth = new Date(year, today.getMonth() + 1, 0).getDate();
                recurringItem.day = lastDayOfMonth; // 実際のデータは変更せず、記録する日付を調整
                const adjustedDateString = `${year}-${month}-${lastDayOfMonth.toString().padStart(2, '0')}`;
                console.log(`日付を調整: ${dateString} -> ${adjustedDateString}`);
            }

            const data = {
                type: recurringItem.type,
                date: dateString,
                category: recurringItem.category,
                amount: recurringItem.amount,
                note: `[定期] ${recurringItem.note || recurringItem.category}`,
                tags: ['定期費'] // tags は任意で追加
            };

            // 既にその月に同じ日付、種別、カテゴリ、金額の記録があるかチェック（簡易的な重複防止）
            const existingEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES);
            const isDuplicate = existingEntries.some(entry =>
                entry.date === data.date &&
                entry.type === data.type &&
                entry.category === data.category &&
                entry.amount === data.amount
            );

            if (!isDuplicate) {
                await saveData(STORE_NAMES.ENTRIES, data);
                addedCount++;
            } else {
                console.log(`重複のためスキップ: ${data.category} (${data.date})`);
            }
        }
        alert(`${addedCount}件の定期的な記録を今月に追加しました。`);
        await loadAndDisplayData();
    });


    // --- 予算設定の機能 ---
    async function saveBudgets(budgets) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readwrite');
            const store = transaction.objectStore(STORE_NAMES.BUDGETS);

            const clearRequest = store.clear(); // 全削除してから保存
            clearRequest.onsuccess = () => {
                const budgetCategories = Object.keys(budgets);
                let addCount = 0;
                if (budgetCategories.length === 0) {
                    resolve(); // 予算がない場合も成功とみなす
                    return;
                }

                budgetCategories.forEach(category => {
                    const budgetItem = { category: category, amount: budgets[category] };
                    const addRequest = store.put(budgetItem);
                    addRequest.onsuccess = () => {
                        addCount++;
                        if (addCount === budgetCategories.length) {
                            console.log('Budgets saved to IndexedDB.');
                            resolve();
                        }
                    };
                    addRequest.onerror = (event) => console.error('Error adding budget:', event.target.errorCode);
                });
            };
            clearRequest.onerror = (event) => {
                console.error('Error clearing budgets store:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function loadBudgets() {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readonly');
            const store = transaction.objectStore(STORE_NAMES.BUDGETS);
            const request = store.getAll();

            request.onsuccess = (event) => {
                const result = event.target.result;
                const budgets = {};
                result.forEach(item => {
                    budgets[item.category] = item.amount;
                });
                resolve(budgets);
            };
            request.onerror = (event) => {
                console.error('Error loading budgets from IndexedDB:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function renderBudgetList() {
        const budgets = await loadBudgets();
        budgetList.innerHTML = '';
        const budgetCategories = Object.keys(budgets);

        if (budgetCategories.length === 0) {
            budgetList.innerHTML = '<p style="text-align: center; color: #777; font-size: 0.9em;">予算が設定されていません。</p>';
            return;
        }

        budgetCategories.forEach(category => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${category}: ¥${budgets[category].toLocaleString()}</span>
                <button class="delete-budget-btn" data-category="${category}">削除</button>
            `;
            budgetList.appendChild(li);
        });

        document.querySelectorAll('.delete-budget-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const categoryToDelete = e.target.dataset.category;
                await deleteBudget(categoryToDelete);
            });
        });
    }

    async function deleteBudget(category) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            if (confirm(`${category}の予算を削除してもよろしいですか？`)) {
                const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readwrite');
                const store = db.objectStore(STORE_NAMES.BUDGETS);
                const request = store.delete(category);

                request.onsuccess = () => {
                    console.log('Budget deleted from IndexedDB:', category);
                    renderBudgetList();
                    updateBudgetStatus(filterAndSortMonthlyData());
                    resolve();
                };
                request.onerror = (event) => {
                    console.error('Error deleting budget from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            } else {
                resolve();
            }
        });
    }

    setBudgetBtn.addEventListener('click', async () => {
        const category = budgetCategorySelect.value;
        const amount = parseInt(budgetAmountInput.value, 10);

        if (!category || isNaN(amount) || amount < 0) {
            alert("カテゴリと予算額は必須入力です。予算額は数値で入力してください。");
            return;
        }

        let budgets = await loadBudgets();
        budgets[category] = amount;
        await saveBudgets(budgets);
        renderBudgetList();
        budgetAmountInput.value = '';
        budgetCategorySelect.value = '';
        updateBudgetStatus(await filterAndSortMonthlyData());
    });

    function initBudgetCategorySelect() {
        const expenseCategories = CATEGORY_OPTIONS["支出"];
        budgetCategorySelect.innerHTML = '<option value="">選択してください</option>';
        expenseCategories.forEach(cat => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.textContent = cat;
            budgetCategorySelect.appendChild(opt);
        });
        // カスタムカテゴリも追加
        Array.from(customCategories).sort().forEach(cat => {
            if (!expenseCategories.includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `${cat} (その他)`;
                budgetCategorySelect.appendChild(opt);
            }
        });
    }

    async function updateBudgetStatus(monthlyDataPromise) {
        const monthlyData = await monthlyDataPromise; // Promiseを解決
        const budgets = await loadBudgets();
        budgetStatusDiv.innerHTML = '<h3>今月の予算実績</h3>';
        let hasBudget = false;

        const monthlyExpensesByCategory = {};
        monthlyData.filter(item => item.type === "支出").forEach(item => {
            // "その他"カテゴリでメモが使われていたらそのメモを実際のカテゴリとして使用
            const actualCategory = (item.category === "その他" && item.note && customCategories.has(item.note)) ? item.note : item.category;
            monthlyExpensesByCategory[actualCategory] = (monthlyExpensesByCategory[actualCategory] || 0) + item.amount;
        });

        for (const category in budgets) {
            hasBudget = true;
            const budgetAmount = budgets[category];
            const actualExpense = monthlyExpensesByCategory[category] || 0;
            const remaining = budgetAmount - actualExpense;
            const isWarning = remaining < 0;

            const budgetItem = document.createElement('div');
            budgetItem.className = `budget-item ${isWarning ? 'warning' : ''}`;
            budgetItem.innerHTML = `
                <span>${category}</span>
                <span>¥${actualExpense.toLocaleString()} / ¥${budgetAmount.toLocaleString()} (${remaining >= 0 ? '残り' : 'オーバー'} ¥${Math.abs(remaining).toLocaleString()})</span>
            `;
            budgetStatusDiv.appendChild(budgetItem);

            // 予算超過通知
            if (isWarning && Notification.permission === 'granted') {
                navigator.serviceWorker.ready.then(registration => {
                    registration.showNotification('予算オーバーのお知らせ', {
                        body: `${currentMonth.getFullYear()}年${currentMonth.getMonth() + 1}月 ${category} の予算が¥${Math.abs(remaining).toLocaleString()}オーバーしています！`,
                        icon: '/icon-192x192.png',
                        tag: `budget-over-${category}-${currentMonth.getFullYear()}-${currentMonth.getMonth()}`,
                        renotify: true // 同じタグの通知を更新
                    });
                });
            }
        }

        if (!hasBudget) {
            budgetStatusDiv.appendChild(noBudgetSetMessage);
        } else {
            if (budgetStatusDiv.contains(noBudgetSetMessage)) {
                noBudgetSetMessage.remove();
            }
        }
    }


    function initFilterCategorySelect() {
        const allCategories = new Set();
        CATEGORY_OPTIONS["支出"].forEach(cat => allCategories.add(cat));
        CATEGORY_OPTIONS["収入"].forEach(cat => allCategories.add(cat));
        customCategories.forEach(cat => allCategories.add(cat));

        filterCategorySelect.innerHTML = '<option value="">すべて</option>';
        Array.from(allCategories).sort().forEach(cat => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.textContent = cat;
            filterCategorySelect.appendChild(opt);
        });
    }

    searchBtn.addEventListener('click', loadAndDisplayData);
    resetFilterBtn.addEventListener('click', async () => {
        filterKeywordInput.value = '';
        filterTypeSelect.value = '';
        filterCategorySelect.value = '';
        filterAmountMinInput.value = '';
        filterAmountMaxInput.value = '';
        await loadAndDisplayData();
    });

    // --- 通知関連関数 ---
    function requestNotificationPermission() {
        if (!('Notification' in window)) {
            console.warn("このブラウザは通知をサポートしていません。");
            return;
        }

        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    console.log('通知許可が与えられました。');
                } else {
                    console.warn('通知許可が拒否されました。');
                }
            });
        }
    }

    function sendEndOfMonthReminder() {
        const today = new Date();
        const year = today.getFullYear();
        const month = today.getMonth(); // 0-indexed

        // 月末日を取得
        const lastDayOfMonth = new Date(year, month + 1, 0).getDate();

        // 今日が月の最終日だったら通知
        if (today.getDate() === lastDayOfMonth && Notification.permission === 'granted') {
            navigator.serviceWorker.ready.then(registration => {
                registration.showNotification('家計簿の締め日です！', {
                    body: '今月の家計簿記録を締め、来月の予算を確認しましょう。',
                    icon: '/icon-192x192.png',
                    tag: `end-of-month-reminder-${year}-${month}`,
                    renotify: false // 同じタグの通知は重複させない
                });
            });
        }
    }

    async function checkRecurringEntriesReminder() {
        const today = new Date();
        const currentMonth = today.getMonth();
        const currentYear = today.getFullYear();
        const recurringEntries = await loadAllDataFromStore(STORE_NAMES.RECURRING_ENTRIES);

        // 今月のエントリーを全て取得
        const allEntries = await loadAllDataFromStore(STORE_NAMES.ENTRIES);
        const thisMonthEntries = allEntries.filter(entry => {
            const entryDate = new Date(entry.date);
            return entryDate.getFullYear() === currentYear && entryDate.getMonth() === currentMonth;
        });

        const missingRecurringEntries = [];

        for (const recurringItem of recurringEntries) {
            // その定期記録が今月すでに登録されているかチェック
            const alreadyAdded = thisMonthEntries.some(entry =>
                entry.type === recurringItem.type &&
                entry.category === recurringItem.category &&
                entry.amount === recurringItem.amount &&
                entry.date.startsWith(`${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}`)
            );

            if (!alreadyAdded) {
                missingRecurringEntries.push(recurringItem);
            }
        }

        if (missingRecurringEntries.length > 0 && Notification.permission === 'granted') {
            const bodyMessage = `今月まだ追加されていない定期的な記録があります: \n${missingRecurringEntries.map(item => `${item.category} (${item.type})`).join('\n')}`;
            navigator.serviceWorker.ready.then(registration => {
                registration.showNotification('定期的な記録の追加忘れ通知', {
                    body: bodyMessage,
                    icon: '/icon-192x192.png',
                    tag: `missing-recurring-entry-${currentYear}-${currentMonth}`,
                    renotify: true // 同じタグの通知を更新
                });
            });
        }
    }

    // --- 初期化関数 ---
    async function init() {
      await openDB();

      // Service Worker の登録
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js', { scope: '/' }) // スコープをルートに設定
            .then((registration) => {
              console.log('Service Worker registered: ', registration);
              // 通知許可を求める
              requestNotificationPermission();
            })
            .catch((error) => {
              console.log('Service Worker registration failed: ', error);
            });
        });
      }

      await loadAllDataForSuggestions(); // カテゴリ、メモ候補の初期ロード
      updateCategoryOptions();
      updateRecurringCategoryOptions();
      initFilterCategorySelect();
      initBudgetCategorySelect();
      await renderRecurringEntryList(); // 定期的な記録のリスト表示
      await renderBudgetList(); // 予算リストの表示
      await loadAndDisplayData(); // 履歴の表示と集計、グラフ更新
      updateMonthDisplay();

      // 通知のチェックを毎日行う（例: 午後10時）
      setInterval(() => {
          const now = new Date();
          if (now.getHours() === 22 && now.getMinutes() === 0) { // 毎日午後10時にチェック
              sendEndOfMonthReminder();
              checkRecurringEntriesReminder();
          }
      }, 60 * 1000); // 1分ごとにチェック
      sendEndOfMonthReminder(); // 起動時にもチェック
      checkRecurringEntriesReminder(); // 起動時にもチェック
    }

    // ページロード時に初期化
    init();

    // フッターナビゲーションのスクロール機能
    document.querySelectorAll('.footer-nav .nav-button').forEach(button => {
        button.addEventListener('click', (e) => {
            const targetId = e.currentTarget.dataset.target;
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    });

  </script>
</body>
</html>
 }
        });
    });

  </script>
</body>
</html>
