<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>家計簿アプリ</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="manifest" href="./manifest.json">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="家計簿">
  <link rel="apple-touch-icon" href="./icon-192x192.png">

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <link rel="icon" type="image/png" href="./icon-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="./icon-512x512.png" sizes="512x512">

  <style>
    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      padding: 1.5em;
      padding-bottom: 60px; /* フッターナビゲーションの高さ分、下部に余白を追加 */
      max-width: 480px;
      margin: auto;
      background: #f0f2f5;
      color: #333;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 1.5em;
      font-size: 2em;
    }

    /* 各セクションの開始位置を示すためにIDにpadding-topとmargin-topを追加 */
    h2 {
      color: #2c3e50;
      margin-top: 2em;
      margin-bottom: 1em;
      padding-top: 60px; /* フッターの高さ分、paddingを追加して要素が隠れないように */
    }
    /* 最初のH2（固定支出の登録）はフォームの後なので、padding-topは不要 */
    h2:first-of-type {
        padding-top: 0;
    }


    form, .fixed-expense-section, .budget-section, .filter-section, .import-section { /* formに加えて新しいセクションにもスタイル適用 */
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 2em;
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    form label, .fixed-expense-section label, .budget-section label, .filter-section label, .import-section label { /* 全てのラベルにスタイル適用 */
      display: block;
      margin-bottom: 0.8em;
      font-weight: bold;
    }

    form label input,
    form label select,
    .fixed-expense-section label input,
    .fixed-expense-section label select,
    .budget-section label input, /* 予算入力フィールド */
    .budget-section label select, /* 予算カテゴリ選択 */
    .filter-section label input, /* 検索入力フィールド */
    .filter-section label select,
    .import-section label input[type="file"] { /* CSVインポートファイル入力フィールド */
      display: block;
      width: calc(100% - 1em);
      padding: 0.7em;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
      box-sizing: border-box;
      margin-top: 0.2em;
    }

    button[type="submit"], .add-fixed-expense-btn, #addMonthlyFixedExpensesBtn,
    .budget-btn, #searchBtn, #resetFilterBtn, #importCsvBtn { /* 全てのボタンの共通スタイル */
      background: #28a745;
      color: white;
      border: none;
      padding: 0.8em;
      cursor: pointer;
      margin-top: 0.5em;
      border-radius: 4px;
      transition: background 0.3s ease;
      width: 100%;
    }

    button[type="submit"]:hover, .add-fixed-expense-btn:hover, #addMonthlyFixedExpensesBtn:hover,
    .budget-btn:hover, #searchBtn:hover, #resetFilterBtn:hover, #importCsvBtn:hover {
      background: #218838;
    }

    #searchBtn { background: #007bff; }
    #searchBtn:hover { background: #0056b3; }
    #resetFilterBtn { background: #6c757d; }
    #resetFilterBtn:hover { background: #5a6268; }
    #importCsvBtn { background: #007bff; } /* インポートボタンも青 */
    #importCsvBtn:hover { background: #0056b3; }


    ul {
      list-style: none;
      padding: 0;
    }

    /* 日付見出しのスタイル */
    .date-header {
      background-color: #e0e0e0;
      padding: 0.8em 1em;
      margin-top: 1.5em;
      margin-bottom: 0.5em;
      font-weight: bold;
      color: #555;
      border-bottom: 1px solid #ddd;
      border-radius: 4px 4px 0 0;
    }

    /* 各日のリストコンテナ */
    .daily-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* 各履歴アイテムのスタイル */
    .daily-list li {
      background: #ffffff;
      margin: 0.2em 0;
      padding: 0.8em 1em;
      border-left: 5px solid;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.05);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    /* 支出と収入のボーダー色 */
    .expense-item {
      border-color: #dc3545;
    }

    .income-item {
      border-color: #28a745;
    }

    /* 各項目詳細のスタイル */
    .item-details {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3em 0.8em;
      margin-right: 1em;
      align-items: baseline;
    }

    .item-type {
      font-weight: bold;
      color: #333;
      min-width: 45px;
      flex-shrink: 0;
    }
    .item-category {
      color: #333;
      font-weight: 500;
      min-width: 70px;
      flex-shrink: 0;
    }
    .item-amount {
      font-weight: bold;
      color: #000;
      margin-left: auto;
      font-size: 1.1em;
      flex-shrink: 0;
    }
    .item-note {
      font-size: 0.9em;
      color: #666;
      flex-basis: 100%;
      margin-top: 0.3em;
    }
    .item-tags { /* タグの表示スタイル */
      font-size: 0.8em;
      color: #007bff;
      flex-basis: 100%;
      margin-top: 0.3em;
    }

    /* 削除ボタンのスタイル */
    .delete-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 0.4em 0.8em;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      flex-shrink: 0;
      margin-left: 0.5em;
      align-self: center;
      transition: background 0.2s ease;
    }

    .delete-btn:hover {
      background: #c82333;
    }

    /* 月切り替えと分析セクション */
    .month-navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 2em;
      margin-bottom: 1.5em;
      background: #ffffff;
      padding: 0.8em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .month-navigation button {
      background: none;
      border: none;
      font-size: 1.5em;
      color: #2c3e50;
      cursor: pointer;
      padding: 0.2em 0.5em;
    }

    .month-display {
      font-size: 1.3em;
      font-weight: bold;
      color: #2c3e50;
    }

    .summary-section {
      background: #ffffff;
      padding: 1.2em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      margin-bottom: 2em;
      text-align: center;
    }

    .summary-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5em;
      font-size: 1.1em;
    }
    .summary-item span:first-child {
      font-weight: bold;
    }
    .summary-item.income span:last-child { color: #28a745; }
    .summary-item.expense span:last-child { color: #dc3545; }
    .summary-item.total span:last-child { font-weight: bold; color: #2c3e50; }

    /* 予算表示のスタイル */
    .budget-status {
        margin-top: 1.5em;
        padding-top: 1em;
        border-top: 1px solid #eee;
    }
    .budget-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5em;
        font-size: 0.95em;
    }
    .budget-item.warning {
        color: #dc3545; /* 予算オーバー警告色 */
        font-weight: bold;
    }
    .budget-item span:first-child {
        font-weight: bold;
    }


    .chart-tabs {
      display: flex;
      justify-content: space-around;
      margin-bottom: 1.5em;
      background: #ffffff;
      padding: 0.5em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .chart-tabs button {
      flex: 1;
      padding: 0.8em 0.5em;
      border: none;
      background: none;
      font-size: 1em;
      cursor: pointer;
      color: #666;
      border-radius: 6px;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .chart-tabs button.active {
      background: #28a745;
      color: white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .chart-tabs button:hover:not(.active) {
      background: #f0f0f0;
    }

    .chart-container {
      background: #ffffff;
      padding: 1.5em;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 2em;
    }
    .chart-container canvas {
      max-width: 100%;
      height: auto;
    }

    /* CSVエクスポートボタンのスタイル */
    #exportCsvBtn {
        width: 100%;
        padding: 0.8em;
        background: #007bff; /* 青色 */
        color: white;
        border: none;
        cursor: pointer;
        margin-top: 1em;
        border-radius: 4px;
        transition: background 0.3s ease;
    }
    #exportCsvBtn:hover {
        background: #0056b3; /* ホバーで少し暗く */
    }

    /* 固定支出リストのスタイル */
    #fixedExpenseList {
        list-style: none;
        padding: 0;
    }
    #fixedExpenseList li {
        background: #f8f8f8;
        padding: 0.8em 1em;
        margin-bottom: 0.5em;
        border-left: 5px solid #6c757d; /* 固定支出は灰色ボーダー */
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    #fixedExpenseList li .delete-fixed-btn {
        background: #dc3545;
        color: white;
        border: none;
        padding: 0.3em 0.6em;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7em;
        transition: background 0.2s ease;
    }
    #fixedExpenseList li .delete-fixed-btn:hover {
        background: #c82333;
    }

    /* 検索フィルタリングセクション */
    .filter-section .filter-buttons {
        display: flex;
        gap: 0.5em;
    }
    .filter-section .filter-buttons button {
        flex: 1;
    }

    /* 入力候補リスト */
    .autocomplete-list {
        list-style: none;
        padding: 0;
        margin-top: 0.5em;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fff;
        max-height: 150px;
        overflow-y: auto;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        position: absolute; /* 親要素が relative であることを想定 */
        width: calc(100% - 3em); /* body padding 考慮 */
        z-index: 100; /* 他の要素より手前に表示 */
    }
    .autocomplete-list li {
        padding: 0.8em 1em;
        cursor: pointer;
        border-bottom: 1px solid #eee;
    }
    .autocomplete-list li:last-child {
        border-bottom: none;
    }
    .autocomplete-list li:hover {
        background-color: #f0f0f0;
    }

    .form-group-relative {
        position: relative;
    }

    /* --- 新しいCSS: フッターナビゲーション --- */
    .footer-nav {
        position: fixed; /* 画面下部に固定 */
        bottom: 0; /* 下端に配置 */
        left: 0;
        width: 100%;
        max-width: 480px; /* bodyのmax-widthに合わせる */
        left: 50%;
        transform: translateX(-50%); /* 中央揃え */
        background: #343a40; /* ダーク系の背景色 */
        display: flex;
        justify-content: space-around;
        padding: 8px 0;
        box-shadow: 0 -2px 8px rgba(0,0,0,0.2); /* 上部に影 */
        z-index: 1000; /* 他の要素より手前に表示 */
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }

    .footer-nav button {
        background: none;
        border: none;
        color: white;
        font-size: 0.8em;
        padding: 0.5em 0.2em;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        flex: 1; /* 等幅で配置 */
        transition: color 0.2s ease;
    }

    .footer-nav button:hover {
        color: #28a745; /* ホバーでアクセントカラー */
    }

    /* アイコン部分のスタイル (Material Iconsなどを使う場合はフォントサイズで調整) */
    .footer-nav button i {
        font-size: 1.4em; /* アイコンのサイズ */
        margin-bottom: 3px;
    }
  </style>
</head>
<body>
  <h1 id="top">家計簿</h1>
  <form id="expense-form">
    <label>種別：
      <select id="type" required>
        <option value="">選択してください</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>

    <label>日付：
      <input type="date" id="date" required />
    </label>

    <label>カテゴリ：
      <select id="category" required>
        <option value="">まず種別を選んでください</option>
      </select>
    </label>

    <label>金額（円）：
      <input type="number" id="amount" required min="0" />
    </label>

    <label class="form-group-relative">メモ：
      <input type="text" id="note" list="memo-suggestions" />
      <datalist id="memo-suggestions"></datalist>
    </label>

    <label>タグ（カンマ区切り）：
      <input type="text" id="tags" placeholder="例: 食事,外食,ランチ" />
    </label>

    <button type="submit">追加</button>
  </form>

  <h2>CSVデータのインポート</h2>
  <div class="import-section">
    <label for="csvFileInput">
      CSVファイルを選択してインポート:
      <input type="file" id="csvFileInput" accept=".csv"/>
    </label>
    <button type="button" id="importCsvBtn">CSVをインポート</button>
  </div>

  <h2 id="budget-section-h2">予算設定</h2>
  <div class="budget-section">
    <h3>月間予算を設定</h3>
    <label>カテゴリ：
      <select id="budgetCategorySelect" required>
        </select>
    </label>
    <label>予算額（円）：
      <input type="number" id="budgetAmountInput" required min="0" />
    </label>
    <button type="button" id="setBudgetBtn" class="budget-btn">予算を設定</button>

    <h3>現在の予算設定</h3>
    <ul id="budgetList">
      </ul>
  </div>

  <h2 id="fixed-expense-section-h2">固定支出の登録</h2>
  <div class="fixed-expense-section">
    <label>カテゴリ：
      <select id="fixedExpenseCategory" required>
        </select>
    </label>
    <label>金額（円）：
      <input type="number" id="fixedExpenseAmount" required min="0" />
    </label>
    <label>メモ：
      <input type="text" id="fixedExpenseNote" />
    </label>
    <button type="button" id="addFixedExpenseBtn" class="add-fixed-expense-btn">固定支出を登録</button>

    <h3>登録済みの固定支出</h3>
    <ul id="fixedExpenseList">
      </ul>
    <button type="button" id="addMonthlyFixedExpensesBtn">今月に固定支出を一括追加</button>
  </div>


  <h2 id="history-section-h2">履歴</h2>
  <div class="month-navigation">
    <button id="prevMonth">&lt;</button>
    <span id="currentMonthDisplay" class="month-display"></span>
    <div style="display: flex; gap: 5px;">
        <select id="selectYear" style="padding: 5px; border-radius: 4px; border: 1px solid #ccc;"></select>
        <select id="selectMonth" style="padding: 5px; border-radius: 4px; border: 1px solid #ccc;"></select>
    </div>
    <button id="nextMonth">&gt;</button>
  </div>

  <div class="filter-section">
    <h3>履歴の検索・絞り込み</h3>
    <label>キーワード（メモ・タグ）：
      <input type="search" id="filterKeyword" placeholder="例: ランチ, #旅行" />
    </label>
    <label>種別：
      <select id="filterType">
        <option value="">すべて</option>
        <option value="支出">支出</option>
        <option value="収入">収入</option>
      </select>
    </label>
    <label>カテゴリ：
      <select id="filterCategory">
        <option value="">すべて</option>
        </select>
    </label>
    <label>金額（下限）：
      <input type="number" id="filterAmountMin" min="0" />
    </label>
    <label>金額（上限）：
      <input type="number" id="filterAmountMax" min="0" />
    </label>
    <div class="filter-buttons">
        <button type="button" id="searchBtn">検索</button>
        <button type="button" id="resetFilterBtn">リセット</button>
    </div>
  </div>

  <ul id="history"></ul>

  <button id="exportCsvBtn">CSVでエクスポート</button>

  <h2 id="analysis-section-h2">分析</h2>
  <div class="summary-section">
    <div class="summary-item income">
      <span>収入</span><span id="totalIncome">¥0</span>
    </div>
    <div class="summary-item expense">
      <span>支出</span><span id="totalExpense">¥0</span>
    </div>
    <hr style="margin: 1em 0; border: none; border-top: 1px solid #eee;">
    <div class="summary-item total">
      <span>合計</span><span id="balance">¥0</span>
    </div>
    <div class="budget-status" id="budgetStatus">
        <h3>今月の予算実績</h3>
        <p style="text-align: center; color: #777; font-size: 0.9em;" id="noBudgetSetMessage">予算が設定されていません。</p>
        </div>
  </div>

  <div class="chart-tabs">
    <button id="pieChartTab" class="active">カテゴリ別（円グラフ）</button>
    <button id="barChartTab">月別推移（棒グラフ）</button>
  </div>

  <div class="chart-container">
    <canvas id="myChart"></canvas>
  </div>

  <div class="footer-nav">
    <button class="nav-button" data-target="top">
        <i class="material-icons">add_circle_outline</i>
        <span>入力</span>
    </button>
    <button class="nav-button" data-target="budget-section-h2">
        <i class="material-icons">account_balance_wallet</i>
        <span>予算</span>
    </button>
    <button class="nav-button" data-target="fixed-expense-section-h2">
        <i class="material-icons">event_note</i>
        <span>固定</span>
    </button>
    <button class="nav-button" data-target="history-section-h2">
        <i class="material-icons">history</i>
        <span>履歴</span>
    </button>
    <button class="nav-button" data-target="analysis-section-h2">
        <i class="material-icons">bar_chart</i>
        <span>分析</span>
    </button>
  </div>

  <script>
    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered: ', registration);
          })
          .catch((error) => {
            console.log('Service Worker registration failed: ', error);
          });
      });
    }

    const form = document.getElementById("expense-form");
    const historyList = document.getElementById("history");
    const typeSelect = document.getElementById("type");
    const categorySelect = document.getElementById("category");
    const amountInput = document.getElementById("amount"); // 金額入力フィールド
    const noteInput = document.getElementById("note"); // メモ入力フィールド
    const tagsInput = document.getElementById("tags"); // タグ入力フィールド
    const currentMonthDisplay = document.getElementById("currentMonthDisplay");
    const prevMonthBtn = document.getElementById("prevMonth");
    const nextMonthBtn = document.getElementById("nextMonth");
    const totalIncomeSpan = document.getElementById("totalIncome");
    const totalExpenseSpan = document.getElementById("totalExpense");
    const balanceSpan = document.getElementById("balance");
    const pieChartTab = document.getElementById("pieChartTab");
    const barChartTab = document.getElementById("barChartTab");
    const myChartCanvas = document.getElementById("myChart");
    const exportCsvBtn = document.getElementById("exportCsvBtn");

    const csvFileInput = document.getElementById("csvFileInput");
    const importCsvBtn = document.getElementById("importCsvBtn");

    // ここから追加
    const selectYear = document.getElementById("selectYear");
    const selectMonth = document.getElementById("selectMonth");
    // ここまで追加

    // 固定支出関連のDOM要素
    const fixedExpenseCategorySelect = document.getElementById("fixedExpenseCategory");
    const fixedExpenseAmountInput = document.getElementById("fixedExpenseAmount");
    const fixedExpenseNoteInput = document.getElementById("fixedExpenseNote");
    const addFixedExpenseBtn = document.getElementById("addFixedExpenseBtn");
    const fixedExpenseList = document.getElementById("fixedExpenseList");
    const addMonthlyFixedExpensesBtn = document.getElementById("addMonthlyFixedExpensesBtn");

    // 予算設定関連のDOM要素
    const budgetCategorySelect = document.getElementById("budgetCategorySelect");
    const budgetAmountInput = document.getElementById("budgetAmountInput");
    const setBudgetBtn = document.getElementById("setBudgetBtn");
    const budgetList = document.getElementById("budgetList");
    const budgetStatusDiv = document.getElementById("budgetStatus");
    const noBudgetSetMessage = document.getElementById("noBudgetSetMessage");

    // フィルタリング・検索関連のDOM要素
    const filterKeywordInput = document.getElementById("filterKeyword");
    const filterTypeSelect = document.getElementById("filterType");
    const filterCategorySelect = document.getElementById("filterCategory");
    const filterAmountMinInput = document.getElementById("filterAmountMin");
    const filterAmountMaxInput = document.getElementById("filterAmountMax");
    const searchBtn = document.getElementById("searchBtn");
    const resetFilterBtn = document.getElementById("resetFilterBtn");
    const memoSuggestionsDatalist = document.getElementById("memo-suggestions");


    const categoryOptions = {
      "支出": [
        "食費", "日用品", "住居", "光熱費", "通信費", "保険", "医療費",
        "被服・美容", "交通", "教育・書籍", "娯楽・交際", "サブスク",
        "税金・年金", "その他"
      ],
      "収入": [
        "給与", "副業", "お小遣い", "配当・投資", "賞与", "その他"
      ]
    };

    // 過去に入力されたカスタムカテゴリやメモを記憶するセット
    let customCategories = new Set();
    let pastNotes = new Set();

    let currentMonth = new Date();
    let myChartInstance;

    document.getElementById("date").valueAsDate = new Date();
    typeSelect.addEventListener("change", updateCategoryOptions);

    // IndexedDBの変数とデータベースオープン関数
    let db;
    const DB_NAME = 'kakeiboDB';
    const DB_VERSION = 1;
    const STORE_NAMES = {
        ENTRIES: 'entries',
        FIXED_EXPENSES: 'fixedExpenses',
        BUDGETS: 'budgets'
    };

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAMES.ENTRIES)) {
                    const entriesStore = db.createObjectStore(STORE_NAMES.ENTRIES, { keyPath: 'id', autoIncrement: true });
                    entriesStore.createIndex('date', 'date', { unique: false });
                    entriesStore.createIndex('type', 'type', { unique: false });
                    entriesStore.createIndex('category', 'category', { unique: false });
                    entriesStore.createIndex('note', 'note', { unique: false });
                    entriesStore.createIndex('tags', 'tags', { unique: false });
                }
                if (!db.objectStoreNames.contains(STORE_NAMES.FIXED_EXPENSES)) {
                    db.createObjectStore(STORE_NAMES.FIXED_EXPENSES, { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(STORE_NAMES.BUDGETS)) {
                    db.createObjectStore(STORE_NAMES.BUDGETS, { keyPath: 'category' });
                }
                console.log('IndexedDB upgraded or created successfully.');
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log('IndexedDB opened successfully.');
                resolve(db);
            };

            request.onerror = (event) => {
                console.error('IndexedDB error:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const data = {
        type: typeSelect.value,
        date: document.getElementById("date").value,
        category: categorySelect.value,
        amount: parseInt(amountInput.value, 10),
        note: noteInput.value,
        tags: tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '')
      };

      if (!data.type || !data.date || !data.category || isNaN(data.amount) || data.amount <= 0) {
        alert("種別、日付、カテゴリ、金額は必須入力です。金額は正の数値を入力してください。");
        return;
      }

      if (data.category === "その他" && data.note) {
          customCategories.add(data.note);
      }
      if (data.note) {
          pastNotes.add(data.note);
      }

      await saveData(data);
      await loadAndDisplayData();
      form.reset();
      updateCategoryOptions();
      updateMemoSuggestions();
    });

    function updateCategoryOptions() {
      const type = typeSelect.value;
      categorySelect.innerHTML = '<option value="">選択してください</option>';

      if (categoryOptions[type]) {
        categoryOptions[type].forEach(cat => {
          const opt = document.createElement("option");
          opt.value = cat;
          opt.textContent = cat;
          categorySelect.appendChild(opt);
        });
      } else {
        categorySelect.innerHTML = '<option value="">まず種別を選んでください</option>';
      }

      if (type === "支出") {
          customCategories.forEach(cat => {
              if (!categoryOptions["支出"].includes(cat)) {
                  const opt = document.createElement("option");
                  opt.value = cat;
                  opt.textContent = `その他 (${cat})`;
                  categorySelect.appendChild(opt);
              }
          });
      }
    }

    function updateMemoSuggestions() {
        memoSuggestionsDatalist.innerHTML = '';
        pastNotes.forEach(note => {
            const option = document.createElement('option');
            option.value = note;
            memoSuggestionsDatalist.appendChild(option);
        });
    }

    /**
     * 家計簿データをIndexedDBに保存する関数
     * @param {object} data 保存する家計簿エントリ
     */
    async function saveData(data) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.ENTRIES], 'readwrite');
            const store = transaction.objectStore(STORE_NAMES.ENTRIES);

            const request = store.put(data);

            request.onsuccess = () => {
                console.log('Data saved to IndexedDB:', data);
                resolve();
            };

            request.onerror = (event) => {
                console.error('Error saving data to IndexedDB:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    /**
     * IndexedDBから全ての家計簿データを読み込む関数
     * @returns {Promise<Array<object>>} 全家計簿データの配列
     */
    async function loadAllData() {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.ENTRIES], 'readonly');
            const store = transaction.objectStore(STORE_NAMES.ENTRIES);
            const request = store.getAll();

            request.onsuccess = (event) => {
                resolve(event.target.result);
            };

            request.onerror = (event) => {
                console.error('Error loading all data from IndexedDB:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    /**
     * 全ての家計簿データをロードし、カスタムカテゴリとメモ候補を更新 (非同期化)
     */
    async function loadAllDataForSuggestions() {
        const allData = await loadAllData() || [];
        customCategories.clear();
        pastNotes.clear();

        allData.forEach(item => {
            if (item.category === "その他" && item.note) {
                customCategories.add(item.note);
            }
            if (item.note) {
                pastNotes.add(item.note);
            }
        });
        updateCategoryOptions();
        updateMemoSuggestions();
    }


    /**
     * 履歴データを読み込み、現在の月に合わせて表示する関数 (非同期化)
     */
    async function loadAndDisplayData() {
        let allData = await loadAllData() || [];
        historyList.innerHTML = "";

        const filterKeyword = filterKeywordInput.value.toLowerCase();
        const filterType = filterTypeSelect.value;
        const filterCategory = filterCategorySelect.value;
        const filterAmountMin = parseInt(filterAmountMinInput.value, 10);
        const filterAmountMax = parseInt(filterAmountMaxInput.value, 10);

        const filteredData = allData.filter(item => {
            const keywordMatch = !filterKeyword ||
                                  (item.note && item.note.toLowerCase().includes(filterKeyword)) ||
                                  (item.tags && item.tags.some(tag => tag.toLowerCase().includes(filterKeyword)));

            const typeMatch = !filterType || item.type === filterType;
            const categoryMatch = !filterCategory || item.category === filterCategory;
            const amountMatch = (isNaN(filterAmountMin) || item.amount >= filterAmountMin) &&
                                 (isNaN(filterAmountMax) || item.amount <= filterAmountMax);

            return keywordMatch && typeMatch && categoryMatch && amountMatch;
        });

        const currentMonthYear = currentMonth.getFullYear();
        const currentMonthMonth = currentMonth.getMonth();

        const monthlyData = filteredData.filter(item => {
            const itemDate = new Date(item.date);
            return itemDate.getFullYear() === currentMonthYear && itemDate.getMonth() === currentMonthMonth;
        });

        monthlyData.sort((a, b) => new Date(b.date) - new Date(a.date));

        const groupedData = {};
        monthlyData.forEach(item => {
            if (!groupedData[item.date]) {
                groupedData[item.date] = [];
            }
            groupedData[item.date].push(item);
        });

        if (Object.keys(groupedData).length === 0) {
            historyList.innerHTML = '<p style="text-align: center; color: #777; margin-top: 2em;">この月には履歴がありません。</p>';
            if (filterKeyword || filterType || filterCategory || !isNaN(filterAmountMin) || !isNaN(filterAmountMax)) {
                historyList.innerHTML += '<p style="text-align: center; color: #777; font-size: 0.9em;">（検索条件に合う項目が見つかりませんでした）</p>';
            }
        } else {
            for (const date in groupedData) {
                if (groupedData.hasOwnProperty(date)) {
                    const dailyItems = groupedData[date];

                    const dateHeader = document.createElement("div");
                    dateHeader.className = "date-header";
                    const [year, month, day] = date.split('-');
                    const dayOfWeek = new Date(date).toLocaleDateString('ja-JP', { weekday: 'short' });
                    const formattedDate = `${year}年${parseInt(month)}月${parseInt(day)}日 (${dayOfWeek})`;

                    dateHeader.textContent = formattedDate;
                    historyList.appendChild(dateHeader);

                    const ul = document.createElement("ul");
                    ul.className = "daily-list";

                    dailyItems.forEach((item) => {
                        const li = document.createElement("li");
                        li.className = item.type === "支出" ? "expense-item" : "income-item";
                        li.innerHTML = `
                            <span class="item-details">
                              <span class="item-type">${item.type}</span>
                              <span class="item-category">${item.category}</span>
                              <span class="item-amount">¥${item.amount.toLocaleString()}</span>
                              ${item.note ? `<span class="item-note">${item.note}</span>` : ''}
                              ${item.tags && item.tags.length > 0 ? `<span class="item-tags">${item.tags.map(tag => `#${tag}`).join(' ')}</span>` : ''}
                            </span>
                            <button class="delete-btn" data-id="${item.id}">削除</button>
                        `;
                        ul.appendChild(li);
                    });
                    historyList.appendChild(ul);
                }
            }
        }

        document.querySelectorAll('.delete-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const idToDelete = parseInt(e.target.dataset.id, 10);
                await deleteData(idToDelete);
            });
        });

        updateMonthDisplay();
        updateSummary(monthlyData);
        updateCharts(monthlyData);
        updateBudgetStatus(monthlyData);
    }

    /**
     * IndexedDBから家計簿データを削除する関数
     * @param {number} id 削除する家計簿エントリのID
     */
    async function deleteData(id) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            if (confirm("この項目を削除してもよろしいですか？")) {
                const transaction = db.transaction([STORE_NAMES.ENTRIES], 'readwrite');
                const store = transaction.objectStore(STORE_NAMES.ENTRIES);
                const request = store.delete(id);

                request.onsuccess = () => {
                    console.log('Data deleted from IndexedDB:', id);
                    loadAndDisplayData();
                    loadAllDataForSuggestions();
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('Error deleting data from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            } else {
                resolve();
            }
        });
    }

    function updateMonthDisplay() {
      const year = currentMonth.getFullYear();
      const month = currentMonth.getMonth() + 1; // getMonth()は0から始まるため+1
      currentMonthDisplay.textContent = `${year}年${month}月`;

      // ドロップダウンを現在の月に合わせる
      selectYear.value = year;
      selectMonth.value = month;
    }

    prevMonthBtn.addEventListener("click", async () => {
      currentMonth.setMonth(currentMonth.getMonth() - 1);
      await loadAndDisplayData();
      updateMonthDropdowns(); // ドロップダウンも更新
    });

    nextMonthBtn.addEventListener("click", async () => {
      currentMonth.setMonth(currentMonth.getMonth() + 1);
      await loadAndDisplayData();
      updateMonthDropdowns(); // ドロップダウンも更新
    });

    // ここから追加
    // ドロップダウンリストに年と月を生成する関数
    async function populateMonthDropdowns() {
        // 現在から過去5年、未来1年分の年を選択肢に入れる
        const currentYear = new Date().getFullYear();
        for (let i = currentYear - 5; i <= currentYear + 1; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `${i}年`;
            selectYear.appendChild(option);
        }

        // 1月から12月までを選択肢に入れる
        for (let i = 1; i <= 12; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `${i}月`;
            selectMonth.appendChild(option);
        }

        // 初期表示を現在の月に合わせる
        updateMonthDropdowns();

        // ドロップダウンが変更されたときのイベントリスナー
        selectYear.addEventListener('change', async () => {
            currentMonth.setFullYear(parseInt(selectYear.value));
            await loadAndDisplayData();
            updateMonthDisplay(); // 月表示（2025年7月）を更新
        });

        selectMonth.addEventListener('change', async () => {
            currentMonth.setMonth(parseInt(selectMonth.value) - 1); // getMonth()は0始まりのため-1
            await loadAndDisplayData();
            updateMonthDisplay(); // 月表示（2025年7月）を更新
        });
    }

    // ドロップダウンの選択をcurrentMonthに合わせる関数
    function updateMonthDropdowns() {
        selectYear.value = currentMonth.getFullYear();
        selectMonth.value = currentMonth.getMonth() + 1;
    }
    // ここまで追加

    function updateSummary(data) {
      let totalIncome = 0;
      let totalExpense = 0;

      data.forEach(item => {
        if (item.type === "収入") {
          totalIncome += item.amount;
        } else if (item.type === "支出") {
          totalExpense += item.amount;
        }
      });

      totalIncomeSpan.textContent = `¥${totalIncome.toLocaleString()}`;
      totalExpenseSpan.textContent = `¥${totalExpense.toLocaleString()}`;
      balanceSpan.textContent = `¥${(totalIncome - totalExpense).toLocaleString()}`;
    }

    async function updateCharts(monthlyData) {
      if (myChartInstance) {
        myChartInstance.destroy();
      }

      const activeTab = document.querySelector('.chart-tabs button.active').id;

      if (activeTab === 'pieChartTab') {
        renderPieChart(monthlyData);
      } else if (activeTab === 'barChartTab') {
        await renderMonthlyBarChart();
      }
    }

    function renderPieChart(monthlyData) {
      const expenseByCategory = {};
      monthlyData.filter(item => item.type === "支出").forEach(item => {
        expenseByCategory[item.category] = (expenseByCategory[item.category] || 0) + item.amount;
      });

      const labels = Object.keys(expenseByCategory);
      const dataValues = Object.values(expenseByCategory);
      const backgroundColors = generateColors(labels.length);

      myChartInstance = new Chart(myChartCanvas, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: dataValues,
            backgroundColor: backgroundColors,
            hoverOffset: 4
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'top',
            },
            title: {
              display: true,
              text: '月間支出カテゴリ別内訳'
            }
          }
        }
      });
    }

    async function renderMonthlyBarChart() {
        const allData = await loadAllData() || [];
        const monthlySummary = {};

        allData.forEach(item => {
            const itemDate = new Date(item.date);
            const yearMonth = `${itemDate.getFullYear()}-${(itemDate.getMonth() + 1).toString().padStart(2, '0')}`;

            if (!monthlySummary[yearMonth]) {
                monthlySummary[yearMonth] = { income: 0, expense: 0 };
            }

            if (item.type === "収入") {
                monthlySummary[yearMonth].income += item.amount;
            } else if (item.type === "支出") {
                monthlySummary[yearMonth].expense += item.amount;
            }
        });

        const sortedMonths = Object.keys(monthlySummary).sort();

        const incomes = sortedMonths.map(month => monthlySummary[month].income);
        const expenses = sortedMonths.map(month => monthlySummary[month].expense);

        myChartInstance = new Chart(myChartCanvas, {
            type: 'bar',
            data: {
                labels: sortedMonths,
                datasets: [
                    {
                        label: '収入',
                        data: incomes,
                        backgroundColor: 'rgba(40, 167, 69, 0.7)',
                        borderColor: 'rgba(40, 167, 69, 1)',
                        borderWidth: 1
                    },
                    {
                        label: '支出',
                        data: expenses,
                        backgroundColor: 'rgba(220, 53, 69, 0.7)',
                        borderColor: 'rgba(220, 53, 69, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: '月別収支推移'
                    }
                },
                scales: {
                    x: {
                        stacked: false
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false
                    }
                }
            }
        });
    }

    function generateColors(numColors) {
      const colors = [];
      const hueStep = 360 / numColors;
      for (let i = 0; i < numColors; i++) {
        const hue = i * hueStep;
        colors.push(`hsl(${hue}, 70%, 60%)`);
      }
      return colors;
    }

    pieChartTab.addEventListener('click', async () => {
      pieChartTab.classList.add('active');
      barChartTab.classList.remove('active');
      updateCharts(await filterAndSortMonthlyData());
    });

    barChartTab.addEventListener('click', async () => {
      barChartTab.classList.add('active');
      pieChartTab.classList.remove('active');
      updateCharts(await filterAndSortMonthlyData());
    });

    async function filterAndSortMonthlyData() {
        const allData = await loadAllData() || [];
        const currentMonthYear = currentMonth.getFullYear();
        const currentMonthMonth = currentMonth.getMonth();

        return allData.filter(item => {
            const itemDate = new Date(item.date);
            return itemDate.getFullYear() === currentMonthYear && itemDate.getMonth() === currentMonthMonth;
        });
    }


    exportCsvBtn.addEventListener('click', async () => {
        const allData = await loadAllData() || [];
        if (allData.length === 0) {
            alert("エクスポートするデータがありません。");
            return;
        }

        const headers = ["日付", "種別", "カテゴリ", "金額", "メモ", "タグ"];
        const csvRows = allData.map(item => {
            const escapeCsv = (value) => {
                if (value === null || value === undefined) return '';
                let stringValue = String(value);
                if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                    return `"${stringValue.replace(/"/g, '""')}"`;
                }
                return stringValue;
            };

            const tagsString = item.tags ? item.tags.join(',') : '';
            return [
                escapeCsv(item.date),
                escapeCsv(item.type),
                escapeCsv(item.category),
                escapeCsv(item.amount),
                escapeCsv(item.note),
                escapeCsv(tagsString)
            ].join(',');
        });

        const csvContent = [headers.join(','), ...csvRows].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

        const link = document.createElement('a');
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', '家計簿データ.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("お使いのブラウザはCSVエクスポートに対応していません。");
        }
    });

    importCsvBtn.addEventListener('click', () => {
        const file = csvFileInput.files[0];
        if (!file) {
            alert("CSVファイルを選択してください。");
            return;
        }

        if (!confirm("CSVファイルをインポートしますか？既存のデータに**追加**されます。（同じ内容が重複する可能性があります）")) {
            return;
        }

        const reader = new FileReader();

        reader.onload = async (e) => {
            const csvText = e.target.result;
            try {
                await parseAndImportCsv(csvText);
                alert("CSVデータのインポートが完了しました！");
                csvFileInput.value = ''; // ファイル選択をリセット
                await loadAndDisplayData(); // 表示を更新
                await loadAllDataForSuggestions(); // メモ候補なども更新
            } catch (error) {
                console.error("CSVインポートエラー:", error);
                alert("CSVファイルの読み込み中にエラーが発生しました。ファイル形式を確認してください。\n" + error.message);
            }
        };

        reader.onerror = (e) => {
            console.error("ファイル読み込みエラー:", e);
            alert("ファイルの読み込み中にエラーが発生しました。");
        };

        reader.readAsText(file, 'UTF-8'); // UTF-8で読み込む
    });

    /**
     * CSVテキストを解析し、IndexedDBに保存する関数
     * @param {string} csvText CSVファイルの文字列データ
     */
    async function parseAndImportCsv(csvText) {
        // ヘッダーをスキップするために最初の行を削除します
        const lines = csvText.trim().split('\n').slice(1); // ヘッダー行をスキップ

        if (lines.length === 0) {
            console.warn("CSVファイルにデータ行がありません。");
            return;
        }

        for (const line of lines) {
            // CSVのパース処理を強化（カンマ区切り、ダブルクォーテーション対応）
            // この正規表現は、CSVの標準的なルール（ダブルクォーテーション内のカンマを無視、""でエスケープされた""を"に変換）に対応します。
            const values = line.match(/(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|([^,]*))(?:,|$)/g)
                               .map(match => {
                                   let val = match.endsWith(',') ? match.slice(0, -1) : match; // 末尾のカンマを削除
                                   if (val.startsWith('"') && val.endsWith('"')) {
                                       val = val.slice(1, -1).replace(/\"\"/g, '\"'); // ダブルクォーテーションを外し、""を"に変換
                                   }
                                   return val;
                               }).filter(val => val !== ""); // 空文字列のエントリを削除

            // エクスポートCSVのヘッダー順: 日付,種別,カテゴリ,金額,メモ,タグ
            if (values.length >= 4) { // 少なくとも日付,種別,カテゴリ,金額は必要
                const type = values[1];
                const date = values[0];
                const category = values[2];
                const amount = parseInt(values[3], 10);
                const note = values[4] || ''; // メモがない場合は空文字列
                const tagsString = values[5] || '';
                const tags = tagsString ? tagsString.split(',').map(tag => tag.trim()).filter(t => t !== '') : [];

                // 必須チェック
                if (!type || !date || !category || isNaN(amount) || amount <= 0) {
                    console.warn("不正なデータ形式の行をスキップしました:", line);
                    continue; // 不正な行はスキップ
                }

                const data = { type, date, category, amount, note, tags };
                await saveData(data); // 既存の保存関数を使用
            } else {
                console.warn("列数が足りない行をスキップしました:", line);
            }
        }
    }

    // 固定支出の機能
    /**
     * 固定支出データをIndexedDBに保存する関数
     * @param {Array<object>} fixedExpenses 保存する固定支出の配列
     */
    async function saveFixedExpenses(fixedExpenses) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.FIXED_EXPENSES], 'readwrite');
            const store = transaction.objectStore(STORE_NAMES.FIXED_EXPENSES);

            const clearRequest = store.clear();
            clearRequest.onsuccess = () => {
                let addCount = 0;
                fixedExpenses.forEach(item => {
                    const addRequest = store.add(item);
                    addRequest.onsuccess = () => {
                        addCount++;
                        if (addCount === fixedExpenses.length) {
                            console.log('Fixed expenses saved to IndexedDB.');
                            resolve();
                        }
                    };
                    addRequest.onerror = (event) => console.error('Error adding fixed expense:', event.target.errorCode);
                });
                if (fixedExpenses.length === 0) {
                    console.log('No fixed expenses to save.');
                    resolve();
                }
            };
            clearRequest.onerror = (event) => {
                console.error('Error clearing fixed expenses store:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    /**
     * IndexedDBから全ての固定支出データを読み込む関数
     * @returns {Promise<Array<object>>} 全固定支出データの配列
     */
    async function loadFixedExpenses() {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.FIXED_EXPENSES], 'readonly');
            const store = transaction.objectStore(STORE_NAMES.FIXED_EXPENSES);
            const request = store.getAll();

            request.onsuccess = (event) => {
                resolve(event.target.result);
            };
            request.onerror = (event) => {
                console.error('Error loading fixed expenses from IndexedDB:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function renderFixedExpenseList() {
        const fixedExpenses = await loadFixedExpenses();
        fixedExpenseList.innerHTML = '';
        if (fixedExpenses.length === 0) {
            fixedExpenseList.innerHTML = '<p style="text-align: center; color: #777; font-size: 0.9em;">登録済みの固定支出はありません。</p>';
            return;
        }
        fixedExpenses.forEach((item) => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${item.category}: ¥${item.amount.toLocaleString()} (${item.note})</span>
                <button class="delete-fixed-btn" data-id="${item.id}">削除</button>
            `;
            fixedExpenseList.appendChild(li);
        });

        document.querySelectorAll('.delete-fixed-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const idToDelete = parseInt(e.target.dataset.id, 10);
                await deleteFixedExpense(idToDelete);
            });
        });
    }

    async function deleteFixedExpense(id) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            if (confirm("この固定支出を削除してもよろしいですか？")) {
                const transaction = db.transaction([STORE_NAMES.FIXED_EXPENSES], 'readwrite');
                const store = transaction.objectStore(STORE_NAMES.FIXED_EXPENSES);
                const request = store.delete(id);

                request.onsuccess = () => {
                    console.log('Fixed expense deleted from IndexedDB:', id);
                    renderFixedExpenseList();
                    resolve();
                };
                request.onerror = (event) => {
                    console.error('Error deleting fixed expense from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            } else {
                resolve();
            }
        });
    }

    addFixedExpenseBtn.addEventListener('click', async () => {
        const category = fixedExpenseCategorySelect.value;
        const amount = parseInt(fixedExpenseAmountInput.value, 10);
        const note = fixedExpenseNoteInput.value;

        if (!category || isNaN(amount) || amount <= 0) {
            alert("カテゴリと金額は必須入力です。金額は正の数値を入力してください。");
            return;
        }

        let fixedExpenses = await loadFixedExpenses();
        fixedExpenses.push({ category, amount, note });
        await saveFixedExpenses(fixedExpenses);
        renderFixedExpenseList();
        fixedExpenseAmountInput.value = '';
        fixedExpenseNoteInput.value = '';
        fixedExpenseCategorySelect.value = '';
    });

    addMonthlyFixedExpensesBtn.addEventListener('click', async () => {
        const fixedExpenses = await loadFixedExpenses();
        if (fixedExpenses.length === 0) {
            alert("登録済みの固定支出がありません。");
            return;
        }

        if (!confirm("今月に登録済みの固定支出をすべて追加しますか？（重複登録にご注意ください）")) {
            return;
        }

        const today = new Date();
        const dateString = today.toISOString().slice(0, 10);

        let addedCount = 0;
        for (const fixedItem of fixedExpenses) {
            const data = {
                type: "支出",
                date: dateString,
                category: fixedItem.category,
                amount: fixedItem.amount,
                note: `[固定] ${fixedItem.note || fixedItem.category}`,
                tags: ['固定費']
            };
            await saveData(data);
            addedCount++;
        }
        alert(`${addedCount}件の固定支出を今月に追加しました。`);
        await loadAndDisplayData();
    });


    // 予算設定の機能
    /**
     * 予算データをIndexedDBに保存する関数
     * @param {object} budgets 保存する予算オブジェクト（カテゴリをキーとする）
     */
    async function saveBudgets(budgets) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readwrite');
            const store = transaction.objectStore(STORE_NAMES.BUDGETS);

            const clearRequest = store.clear();
            clearRequest.onsuccess = () => {
                const budgetCategories = Object.keys(budgets);
                let addCount = 0;
                if (budgetCategories.length === 0) {
                    console.log('No budgets to save.');
                    resolve();
                    return;
                }

                budgetCategories.forEach(category => {
                    const budgetItem = { category: category, amount: budgets[category] };
                    const addRequest = store.put(budgetItem);
                    addRequest.onsuccess = () => {
                        addCount++;
                        if (addCount === budgetCategories.length) {
                            console.log('Budgets saved to IndexedDB.');
                            resolve();
                        }
                    };
                    addRequest.onerror = (event) => console.error('Error adding budget:', event.target.errorCode);
                });
            };
            clearRequest.onerror = (event) => {
                console.error('Error clearing budgets store:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    /**
     * IndexedDBから全ての予算データを読み込む関数
     * @returns {Promise<object>} 予算オブジェクト（カテゴリをキーとする）
     */
    async function loadBudgets() {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readonly');
            const store = transaction.objectStore(STORE_NAMES.BUDGETS);
            const request = store.getAll();

            request.onsuccess = (event) => {
                const result = event.target.result;
                const budgets = {};
                result.forEach(item => {
                    budgets[item.category] = item.amount;
                });
                resolve(budgets);
            };
            request.onerror = (event) => {
                console.error('Error loading budgets from IndexedDB:', event.target.errorCode);
                reject(event.target.errorCode);
            };
        });
    }

    async function renderBudgetList() {
        const budgets = await loadBudgets();
        budgetList.innerHTML = '';
        const budgetCategories = Object.keys(budgets);

        if (budgetCategories.length === 0) {
            budgetList.innerHTML = '<p style="text-align: center; color: #777; font-size: 0.9em;">予算が設定されていません。</p>';
            return;
        }

        budgetCategories.forEach(category => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${category}: ¥${budgets[category].toLocaleString()}</span>
                <button class="delete-budget-btn" data-category="${category}">削除</button>
            `;
            budgetList.appendChild(li);
        });

        document.querySelectorAll('.delete-budget-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const categoryToDelete = e.target.dataset.category;
                await deleteBudget(categoryToDelete);
            });
        });
    }

    async function deleteBudget(category) {
        if (!db) await openDB();
        return new Promise((resolve, reject) => {
            if (confirm(`${category}の予算を削除してもよろしいですか？`)) {
                const transaction = db.transaction([STORE_NAMES.BUDGETS], 'readwrite');
                const store = db.objectStore(STORE_NAMES.BUDGETS);
                const request = store.delete(category);

                request.onsuccess = () => {
                    console.log('Budget deleted from IndexedDB:', category);
                    renderBudgetList();
                    updateBudgetStatus(filterAndSortMonthlyData());
                    resolve();
                };
                request.onerror = (event) => {
                    console.error('Error deleting budget from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            } else {
                resolve();
            }
        });
    }

    setBudgetBtn.addEventListener('click', async () => {
        const category = budgetCategorySelect.value;
        const amount = parseInt(budgetAmountInput.value, 10);

        if (!category || isNaN(amount) || amount < 0) {
            alert("カテゴリと予算額は必須入力です。予算額は数値で入力してください。");
            return;
        }

        let budgets = await loadBudgets();
        budgets[category] = amount;
        await saveBudgets(budgets);
        renderBudgetList();
        budgetAmountInput.value = '';
        budgetCategorySelect.value = '';
        updateBudgetStatus(await filterAndSortMonthlyData());
    });

    function initBudgetCategorySelect() {
        const expenseCategories = categoryOptions["支出"];
        budgetCategorySelect.innerHTML = '<option value="">選択してください</option>';
        expenseCategories.forEach(cat => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.textContent = cat;
            budgetCategorySelect.appendChild(opt);
        });
        customCategories.forEach(cat => {
            if (!expenseCategories.includes(cat)) {
                const opt = document.createElement("option");
                opt.value = cat;
                opt.textContent = `その他 (${cat})`;
                budgetCategorySelect.appendChild(opt);
            }
        });
    }


    async function updateBudgetStatus(monthlyData) {
        const budgets = await loadBudgets();
        budgetStatusDiv.innerHTML = '<h3>今月の予算実績</h3>';
        let hasBudget = false;

        const monthlyExpensesByCategory = {};
        monthlyData.filter(item => item.type === "支出").forEach(item => {
            const actualCategory = (item.category === "その他" && item.note && customCategories.has(item.note)) ? item.note : item.category;
            monthlyExpensesByCategory[actualCategory] = (monthlyExpensesByCategory[actualCategory] || 0) + item.amount;
        });

        for (const category in budgets) {
            hasBudget = true;
            const budgetAmount = budgets[category];
            const actualExpense = monthlyExpensesByCategory[category] || 0;
            const remaining = budgetAmount - actualExpense;
            const isWarning = remaining < 0;

            const budgetItem = document.createElement('div');
            budgetItem.className = `budget-item ${isWarning ? 'warning' : ''}`;
            budgetItem.innerHTML = `
                <span>${category}</span>
                <span>¥${actualExpense.toLocaleString()} / ¥${budgetAmount.toLocaleString()} (${remaining >= 0 ? '残り' : 'オーバー'} ¥${Math.abs(remaining).toLocaleString()})</span>
            `;
            budgetStatusDiv.appendChild(budgetItem);
        }

        if (!hasBudget) {
            budgetStatusDiv.appendChild(noBudgetSetMessage);
        } else {
            noBudgetSetMessage.remove();
        }
    }

    function initFilterCategorySelect() {
        const allCategories = new Set();
        categoryOptions["支出"].forEach(cat => allCategories.add(cat));
        categoryOptions["収入"].forEach(cat => allCategories.add(cat));
        customCategories.forEach(cat => allCategories.add(cat));

        filterCategorySelect.innerHTML = '<option value="">すべて</option>';
        Array.from(allCategories).sort().forEach(cat => {
            const opt = document.createElement("option");
            opt.value = cat;
            opt.textContent = cat;
            filterCategorySelect.appendChild(opt);
        });
    }

    searchBtn.addEventListener('click', loadAndDisplayData);
    resetFilterBtn.addEventListener('click', async () => {
        filterKeywordInput.value = '';
        filterTypeSelect.value = '';
        filterCategorySelect.value = '';
        filterAmountMinInput.value = '';
        filterAmountMaxInput.value = '';
        await loadAndDisplayData();
    });

    // 初期化関数
    async function init() {
      await openDB();
      await loadAllDataForSuggestions();
      updateCategoryOptions();
      initFilterCategorySelect();
      initBudgetCategorySelect();
      await renderFixedExpenseList();
      await renderBudgetList();
      await loadAndDisplayData();
      updateCharts(await filterAndSortMonthlyData());
      await populateMonthDropdowns(); // ドロップダウンを初期化
    }

    // ページロード時に初期化
    init();

    // フッターナビゲーションのスクロール機能
    document.querySelectorAll('.footer-nav .nav-button').forEach(button => {
        button.addEventListener('click', (e) => {
            const targetId = e.currentTarget.dataset.target;
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    });

  </script>
</body>
</html>
